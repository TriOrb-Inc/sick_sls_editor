<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SICK SLS Editor (Web)</title>
    <link rel="icon" type="image/png" href="/static/favicon.ico" />
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <style>
      :root {
        color-scheme: light;
        font-family: "Segoe UI", "Yu Gothic UI", system-ui, -apple-system, sans-serif;
      }


      body {
        margin: 0;
        background: #eef1f5;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        background: #0b6fb8;
        color: #fff;
        padding: 1rem 1.5rem;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      }

      header p {
        margin: 0.2rem 0 0;
      }

      main {
        width: 95%;
        margin: 2rem auto;
        padding: 1.5rem;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(15, 23, 42, 0.1);
        flex: 1;
        display: flex;
        gap: 1.5rem;
        align-items: flex-start;
      }

      .content-area {
        flex: 1 1 65%;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .side-menu {
        flex: 0 0 360px;
        max-height: calc(100vh - 4rem);
        overflow-y: auto;
        padding-right: 0.5rem;
        position: sticky;
        top: 2rem;
        align-self: flex-start;
      }

      .side-menu::-webkit-scrollbar {
        width: 6px;
      }

      .side-menu::-webkit-scrollbar-thumb {
        background: rgba(15, 23, 42, 0.25);
        border-radius: 3px;
      }

      .toolbar {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-start;
      }

      .toolbar-primary {
        width: 100%;
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }

      .toolbar-toggle {
        width: 100%;
        display: flex;
        justify-content: flex-start;
      }

      button,
      label.upload-btn,
      .inline-btn {
        border: none;
        border-radius: 6px;
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        cursor: pointer;
        background: #0b6fb8;
        color: #fff;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        box-shadow: 0 1px 3px rgba(15, 23, 42, 0.2);
      }

      .legend-toggle-btn {
        background: #475569;
        font-size: 0.75rem;
        padding: 0.35rem 0.75rem;
        color: #e2e8f0;
      }

      button.secondary {
        background: #475569;
      }

      .inline-btn.inline-danger {
        background: #c53030;
      }
      label.upload-btn {
        position: relative;
      }

      label.upload-btn input[type="file"] {
        position: absolute;
        inset: 0;
        opacity: 0;
        cursor: pointer;
      }

      #status-text {
        margin-left: auto;
        font-size: 0.9rem;
        color: #475569;
      }

      #status-text[data-state="error"] {
        color: #c53030;
      }

      #status-text[data-state="warning"] {
        color: #d97706;
      }

      .plot-wrapper {
        width: 100%;
        max-width: none;
        min-height: 420px;
      }

      #plot {
        width: 100%;
        min-height: 520px;
        height: clamp(420px, 65vh, 900px);
      }

      .fieldset-filter {
        margin-top: 1rem;
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.75rem;
        background: #f8fafc;
      }

      .fieldset-filter-controls {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 0.75rem;
      }

      #fieldset-checkboxes {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem 1rem;
      }

      .fieldset-checkbox {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.9rem;
      }

      .triorb-shape-filter {
        margin-top: 1rem;
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.75rem;
        background: #f1f5f9;
      }
      .triorb-structure-actions {
        margin-top: 0.75rem;
        display: flex;
        justify-content: flex-start;
      }

      .triorb-shape-checkbox {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.9rem;
      }

      .side-menu {
        flex: 0 0 auto;
        min-width: 220px;
        max-width: 40%;
        width: fit-content;
        background: #f6f8fb;
        border-radius: 10px;
        padding: 1rem;
        box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.05);
      }

      .side-menu h2 {
        font-size: 1rem;
        margin: 0 0 0.75rem;
        color: #1f2937;
      }

      .menu-section {
        border: 1px solid rgba(15, 23, 42, 0.08);
        border-radius: 8px;
        margin-bottom: 0.5rem;
        background: #fff;
      }

      .menu-section summary {
        cursor: pointer;
        padding: 0.6rem 0.8rem;
        font-weight: 600;
        color: #0b6fb8;
        list-style: none;
      }

      .menu-section summary::-webkit-details-marker {
        display: none;
      }

      .menu-section summary::after {
        content: "+";
        float: right;
        font-weight: normal;
        color: #64748b;
      }

      .menu-section[open] summary::after {
        content: "-";
      }

      .menu-content {
        padding: 0.6rem 0.8rem 1rem;
        color: #475569;
        font-size: 0.9rem;
        border-top: 1px solid rgba(15, 23, 42, 0.06);
      }

      .menu-description {
        margin: 0 0 0.6rem;
        color: #1f2937;
        font-weight: 500;
      }

      .menu-fileinfo-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 0.7rem 1rem;
      }

      .menu-fileinfo-field label {
        display: block;
        margin-bottom: 0.25rem;
        font-size: 0.8rem;
        font-weight: 600;
        color: #475569;
      }

      .menu-fileinfo-field input {
        width: 100%;
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.45rem 0.6rem;
        font-size: 0.9rem;
        background: #fff;
      }

      .triorb-field label {
        display: block;
        margin-bottom: 0.25rem;
        font-size: 0.8rem;
        font-weight: 600;
        color: #475569;
      }

      .triorb-field input,
      .triorb-field select {
        width: 100%;
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.45rem 0.6rem;
        font-size: 0.9rem;
        background: #e6f2ff;
      }

      .menu-fileinfo-field input:focus,
      .scanplane-card input:focus,
      .device-card input:focus,
      .fieldset-field input:focus,
      .field-attribute input:focus {
        outline: 2px solid rgba(11, 111, 184, 0.35);
        border-color: rgba(11, 111, 184, 0.65);
      }

      .scanplanes-editor {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .scanplane-card,
      .device-card {
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.6rem;
        background: #fefefe;
      }

      .scanplane-details summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
        font-weight: 600;
        color: #0b6fb8;
        cursor: pointer;
      }

      .scanplane-details summary::-webkit-details-marker {
        display: none;
      }

      .scanplane-summary {
        font-size: 0.85rem;
        color: #475569;
      }

      .scanplane-fields,
      .device-fields {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 0.4rem 0.6rem;
      }

      .scanplane-field,
      .device-field {
        display: flex;
        flex-direction: column;
        font-size: 0.85rem;
      }

      .scanplane-field label,
      .device-field label {
        margin-bottom: 0.2rem;
        font-weight: 600;
        color: #475569;
      }

      .scanplane-field input,
      .device-field input {
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.35rem 0.45rem;
        font-size: 0.85rem;
      }

      .device-card {
        margin-top: 0.5rem;
        background: #fff;
      }

      .device-details summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: #334155;
        cursor: pointer;
      }

      .device-details summary::-webkit-details-marker {
        display: none;
      }

      .device-summary {
        font-size: 0.8rem;
        color: #64748b;
      }

      select {
        background: #e6f2ff;
      }

      .fieldsets-editor {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .fieldset-card {
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.6rem;
        background: #fff;
      }

      .fieldset-details summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: #0d4b91;
        cursor: pointer;
      }

      .fieldset-details summary::-webkit-details-marker {
        display: none;
      }

      .fieldset-summary {
        font-size: 0.8rem;
        color: #475569;
        margin-left: 0.5rem;
      }

      .fieldset-fields,
      .field-attributes {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.5rem;
      }

      .fieldset-field,
      .field-attribute {
        display: flex;
        flex-direction: column;
        font-size: 0.85rem;
      }

      .casetable-section {
        margin-top: 1rem;
        padding: 0.75rem;
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        background: #f8fafc;
      }

      .casetable-section h3 {
        margin: 0 0 0.5rem;
        font-size: 1rem;
        color: #0d4b91;
      }

      .casetable-configuration details {
        border: 1px solid rgba(15, 23, 42, 0.08);
        border-radius: 6px;
        padding: 0.4rem 0.6rem;
        background: #fff;
        margin-bottom: 0.5rem;
      }

      .casetable-configuration summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: #0f172a;
        cursor: pointer;
      }

      .casetable-config-attrs {
        margin-top: 0.5rem;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 0.5rem;
      }

      .casetable-config-attrs label {
        font-size: 0.8rem;
        font-weight: 600;
        margin-bottom: 0.15rem;
        color: #475569;
      }

      .casetable-config-attrs input,
      .casetable-config-attrs textarea {
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.35rem 0.45rem;
        font-size: 0.85rem;
        width: 100%;
      }

      .casetable-config-text {
        min-height: 60px;
        resize: vertical;
      }

      .casetable-cases-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .casetable-case-count {
        margin-left: auto;
        font-size: 0.85rem;
        color: #475569;
      }

      .casetable-cases-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin-top: 0.5rem;
      }

      .casetable-case-card {
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        background: #fff;
      }

      .casetable-case-card summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        font-weight: 600;
        color: #0d4b91;
        cursor: pointer;
      }

      .casetable-case-card summary::-webkit-details-marker {
        display: none;
      }

      .casetable-case-body {
        padding: 0.5rem 0.75rem 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .casetable-case-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.5rem;
      }

      .casetable-case-field {
        display: flex;
        flex-direction: column;
        font-size: 0.85rem;
      }

      .casetable-case-field label {
        font-weight: 600;
        color: #475569;
        margin-bottom: 0.2rem;
      }

      .casetable-case-field input {
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.35rem 0.45rem;
        font-size: 0.85rem;
      }

      .casetable-static-inputs {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .casetable-static-group {
        flex: 1 1 160px;
      }

      .casetable-static-label {
        font-size: 0.8rem;
        font-weight: 600;
        color: #475569;
        margin-bottom: 0.35rem;
        display: block;
      }

      .toggle-group {
        display: inline-flex;
        border: 1px solid rgba(15, 23, 42, 0.2);
        border-radius: 999px;
        overflow: hidden;
      }

      .toggle-option {
        border: none;
        background: transparent;
        padding: 0.35rem 0.9rem;
        font-size: 0.8rem;
        color: #475569;
        cursor: pointer;
      }

      .toggle-option.is-active {
        background: #0b6fb8;
        color: #fff;
      }

      .casetable-speed-activation {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.5rem;
      }

      .casetable-speed-activation label {
        font-size: 0.85rem;
        font-weight: 600;
        color: #475569;
      }

      .casetable-speed-activation select {
        min-width: 160px;
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.35rem 0.45rem;
        font-size: 0.85rem;
        background: #fff;
      }

      .casetable-help-text {
        font-size: 0.8rem;
        color: #64748b;
        margin-top: 0.35rem;
      }

      .casetable-readonly-note {
        font-size: 0.75rem;
        color: #94a3b8;
      }

      .debug-hidden {
        display: none !important;
      }

      body.debug-mode .debug-hidden {
        display: flex !important;
      }

      .fieldset-field label,
      .field-attribute label {
        margin-bottom: 0.2rem;
        font-weight: 600;
        color: #475569;
      }

      .fieldset-field input,
      .field-attribute input {
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.35rem 0.45rem;
        font-size: 0.85rem;
      }

      .field-card {
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.5rem;
        background: #fefefe;
        margin-top: 0.5rem;
      }

      .field-details summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: #0d4b91;
        cursor: pointer;
      }

      .field-details summary::-webkit-details-marker {
        display: none;
      }

      .field-summary {
        font-size: 0.8rem;
        color: #64748b;
        margin-left: 0.5rem;
      }

      .shape-section {
        margin-top: 0.5rem;
      }

      .shape-list {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }

      .triorb-shapes-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin-top: 0.5rem;
      }

      .triorb-shape-card {
        border: 1px solid rgba(15, 23, 42, 0.15);
        border-radius: 10px;
        padding: 0.6rem;
        background: #f1f5f9;
      }

      .triorb-shape-card .shape-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .triorb-shape-card .shape-row label {
        margin: 0;
        font-weight: 600;
      }

      .triorb-shape-card .shape-details {
        margin-top: 0.6rem;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.4rem;
      }

      .triorb-shape-card input,
      .triorb-shape-card select {
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.3rem 0.4rem;
      }

      .shape-entry {
        border: 1px dashed rgba(15, 23, 42, 0.2);
        border-radius: 6px;
        padding: 0.4rem 0.5rem;
        background: #f9fafb;
      }

      .shape-title {
        font-weight: 600;
        margin-bottom: 0.3rem;
        color: #475569;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
      }

      .modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 999;
      }

      .modal.active {
        display: flex;
      }

      .modal-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(15, 23, 42, 0.45);
      }

      .modal-window {
        position: relative;
        background: #fff;
        border-radius: 12px;
        width: min(480px, 90vw);
        max-height: 85vh;
        overflow-y: auto;
        padding: 1rem;
        box-shadow: 0 10px 40px rgba(15, 23, 42, 0.35);
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.75rem;
      }

      .modal-title {
        font-size: 1.1rem;
        font-weight: 700;
        color: #0f172a;
      }

      .modal-body {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }

      .modal-footer {
        margin-top: 1rem;
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
      }

      .modal-field {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      .modal-field input {
        width: 100%;
      }

      .shape-badges {
        display: flex;
        flex-wrap: wrap;
        gap: 0.3rem;
        font-size: 0.75rem;
      }

      .shape-points {
        margin-top: 0.25rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
        font-size: 0.8rem;
        color: #475569;
      }

      .shape-point {
        display: flex;
        flex-wrap: wrap;
        gap: 0.3rem;
        align-items: center;
      }

      .shape-point label {
        margin: 0;
        font-weight: 500;
      }

      .shape-point input {
        width: 5rem;
      }

      .fieldset-actions,
      .field-actions {
        margin-top: 0.5rem;
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
      }

      .shape-actions {
        margin-top: 0.5rem;
        display: flex;
        gap: 0.4rem;
        flex-wrap: wrap;
        justify-content: flex-start;
      }

      .fieldset-global-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 0.4rem 0.6rem;
      }

      .scanplane-actions {
        margin-top: 0.6rem;
        display: flex;
        justify-content: flex-end;
      }

      .device-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.4rem;
        font-weight: 600;
        color: #334155;
      }

      .shape-mini-btn {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
      }
      .modal-resize-handle {
        position: absolute;
        width: 16px;
        height: 16px;
        right: 6px;
        bottom: 6px;
        cursor: se-resize;
        background: rgba(15, 23, 42, 0.35);
        border-radius: 3px;
      }
      .shape-create-window {
        max-width: 720px;
      }
      .shape-create-body .modal-section {
        margin-bottom: 0.85rem;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .shape-polygon-group,
      .shape-rectangle-group,
      .shape-circle-group {
        display: none;
        gap: 0.35rem;
      }
      .shape-polygon-group.active,
      .shape-rectangle-group.active,
      .shape-circle-group.active {
        display: flex;
        flex-direction: column;
      }
      .shape-rectangle-group,
      .shape-circle-group {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .shape-create-body input,
      .shape-create-body textarea,
      .shape-create-body select {
        width: 100%;
      }
      .shape-create-body textarea {
        resize: vertical;
      }
      .shape-create-window .two-column {
        display: grid;
        gap: 0.5rem;
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .fieldset-checkbox-grid {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        max-height: 180px;
        overflow-y: auto;
      }
      .toggle-pill-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
        max-height: 220px;
        overflow-y: auto;
      }
      .toggle-pill-btn {
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.35rem 0.85rem;
        border-radius: 999px;
        background: #f8fafc;
        color: #0f172a;
        font-size: 0.85rem;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      }
      .toggle-pill-btn.active {
        background: #0b6fb8;
        color: #ffffff;
        border-color: transparent;
        transform: translateY(-1px);
      }
      .toggle-pill-empty {
        color: #475569;
        font-size: 0.9rem;
      }
      .preview-note {
        font-size: 0.85rem;
        color: #c53030;
      }
      .plot-overlay-controls {
        position: absolute;
        top: 2rem;
        right: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .plot-wrapper {
        position: relative;
      }

      footer {
        text-align: center;
        font-size: 0.85rem;
        color: #4a5568;
        margin-bottom: 2rem;
      }

      @media (max-width: 960px) {
        main {
          flex-direction: column;
        }

        .side-menu {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div id="shape-modal" class="modal" aria-hidden="true">
      <div class="modal-backdrop" data-action="close-modal"></div>
      <div class="modal-window" role="dialog" aria-modal="true">
        <div class="modal-header">
          <span class="modal-title" id="shape-modal-title"></span>
          <button type="button" class="inline-btn inline-danger shape-mini-btn" id="shape-modal-close">
            ×
          </button>
        </div>
        <div class="modal-body" id="shape-modal-body"></div>
        <div class="modal-footer">
          <button type="button" class="inline-btn secondary" id="shape-modal-cancel">Cancel</button>
          <button type="button" class="inline-btn" id="shape-modal-save">Save</button>
        </div>
      </div>
    </div>
    <div id="create-shape-modal" class="modal" aria-hidden="true">
      <div class="modal-backdrop" data-action="close-create-shape"></div>
      <div class="modal-window shape-create-window" role="dialog" aria-modal="true">
        <div class="modal-header">
          <span class="modal-title">Add Shape</span>
          <button type="button" class="inline-btn inline-danger shape-mini-btn" id="create-shape-modal-close">
            ×
          </button>
        </div>
        <div class="modal-body shape-create-body">
          <div class="modal-section">
            <label>Name</label>
            <input type="text" id="create-shape-name" placeholder="Shape name" />
          </div>
          <div class="modal-section two-column">
            <label>Fieldtype</label>
            <select id="create-shape-fieldtype">
              <option value="ProtectiveSafeBlanking">ProtectiveSafeBlanking</option>
              <option value="WarningSafeBlanking">WarningSafeBlanking</option>
            </select>
            <label>Type</label>
            <select id="create-shape-kind">
              <option value="Field">Field</option>
              <option value="CutOut">CutOut</option>
            </select>
            <label>Shape Type</label>
            <select id="create-shape-type">
              <option value="Polygon">Polygon</option>
              <option value="Rectangle">Rectangle</option>
              <option value="Circle">Circle</option>
            </select>
          </div>
          <div class="modal-section" id="create-shape-dimension-fields">
            <div class="shape-polygon-group">
              <label>Polygon points (format: (x,y),(x,y))</label>
              <textarea id="create-shape-points" rows="3"></textarea>
            </div>
            <div class="shape-dimension-grid shape-rectangle-group" data-shape="rectangle">
              <label>OriginX</label>
              <input type="number" id="create-rect-originx" value="0" />
              <label>OriginY</label>
              <input type="number" id="create-rect-originy" value="0" />
              <label>Width</label>
              <input type="number" id="create-rect-width" value="100" />
              <label>Height</label>
              <input type="number" id="create-rect-height" value="100" />
              <label>Rotation</label>
              <input type="number" id="create-rect-rotation" value="0" />
            </div>
            <div class="shape-dimension-grid shape-circle-group" data-shape="circle">
              <label>CenterX</label>
              <input type="number" id="create-circle-centerx" value="0" />
              <label>CenterY</label>
              <input type="number" id="create-circle-centery" value="0" />
              <label>Radius</label>
              <input type="number" id="create-circle-radius" value="100" />
            </div>
          </div>
          <div class="modal-section">
            <label>Attach to Fieldsets</label>
            <div id="create-shape-fieldset-list" class="toggle-pill-grid"></div>
          </div>
          <div class="modal-section preview-note">
            <p>Live preview will be shown as a red overlay while editing.</p>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="inline-btn secondary" id="create-shape-modal-cancel">Cancel</button>
          <button type="button" class="inline-btn" id="create-shape-modal-save">Add Shape</button>
        </div>
      </div>
    </div>
    <header>
      <h1>TriOrb - SICK SLS Editor</h1>
    </header>
    <main>
      <section class="content-area">
        <div class="toolbar">
          <div class="toolbar-primary">
            <button id="btn-new" type="button">New</button>
        <button id="btn-save-triorb" type="button" class="secondary">Save (TriOrb)</button>
        <button id="btn-save-sick" type="button" class="inline-btn">Save (SICK)</button>
            <label class="upload-btn">
              Load (XML)
              <input id="file-input" type="file" accept=".xml,.sgexml" />
            </label>
            <span id="status-text">Ready</span>
          </div>
          <div class="toolbar-toggle">
            <button id="btn-toggle-legend" type="button" class="legend-toggle-btn">Hide Legend</button>
          </div>
        </div>
        <div class="plot-wrapper">
          <div id="plot"></div>
          <div class="plot-overlay-controls">
            <button id="btn-add-shape-overlay" type="button">+ Shape</button>
            <button id="btn-add-field-overlay" type="button">＋Field</button>
          </div>
        </div>
        <div class="fieldset-filter">
          <div class="fieldset-filter-controls">
            <button type="button" class="inline-btn" id="btn-fieldset-check-all">All check</button>
            <button type="button" class="inline-btn" id="btn-fieldset-uncheck-all">All uncheck</button>
          </div>
          <div id="fieldset-checkboxes"></div>
        </div>
        <div class="triorb-shape-filter">
          <div class="fieldset-filter-controls">
            <button type="button" class="inline-btn" id="btn-triorb-shape-check-all">Show All Shapes</button>
            <button type="button" class="inline-btn" id="btn-triorb-shape-uncheck-all">Hide All Shapes</button>
          </div>
          <div id="triorb-shape-checkboxes"></div>
        </div>
      </section>
      <aside class="side-menu">
        <h2>Structure Menu</h2>
        
        
        <details class="menu-section" open>
        
          <summary>FileInfo</summary>
          <div class="menu-content">
            
              <p class="menu-description">No additional attributes</p>
              
              <div class="menu-fileinfo-grid" data-scope="fileinfo">
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-ContentId">ContentId</label>
                  <input
                    id="fileinfo-ContentId"
                    type="text"
                    value="Scanner Complete Export"
                    data-field="ContentId"
                  />
                </div>
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-ContentVersion">ContentVersion</label>
                  <input
                    id="fileinfo-ContentVersion"
                    type="text"
                    value="1.6"
                    data-field="ContentVersion"
                  />
                </div>
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-Company">Company</label>
                  <input
                    id="fileinfo-Company"
                    type="text"
                    value="TriOrb"
                    data-field="Company"
                  />
                </div>
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-CreationToolName">CreationToolName</label>
                  <input
                    id="fileinfo-CreationToolName"
                    type="text"
                    value="TriOrb - SICK SLS Editor"
                    data-field="CreationToolName"
                  />
                </div>
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-CreationToolVersion">CreationToolVersion</label>
                  <input
                    id="fileinfo-CreationToolVersion"
                    type="text"
                    value="2025.11"
                    data-field="CreationToolVersion"
                  />
                </div>
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-CreationComponentName">CreationComponentName</label>
                  <input
                    id="fileinfo-CreationComponentName"
                    type="text"
                    value="nanoScan3"
                    data-field="CreationComponentName"
                  />
                </div>
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-CreationComponentVersion">CreationComponentVersion</label>
                  <input
                    id="fileinfo-CreationComponentVersion"
                    type="text"
                    value="1.19.23369.0"
                    data-field="CreationComponentVersion"
                  />
                </div>
                
              </div>
              
            
          </div>
        </details>
        
        
        <details class="menu-section" >
        
          <summary>Export_ScanPlanes</summary>
          <div class="menu-content">
            
              <p class="menu-description">No additional attributes</p>
              <button type="button" class="inline-btn" id="btn-add-scanplane">Add ScanPlane</button>
              <div class="scanplanes-editor" id="scanplanes-editor"></div>
            
          </div>
        </details>
        
        
        <details class="menu-section" >
        
          <summary>Export_FieldsetsAndFields</summary>
          <div class="menu-content">
            
              <p class="menu-description">No additional attributes</p>
              <button type="button" class="inline-btn" id="btn-add-fieldset">Add Fieldset</button>
              <details class="menu-section" id="fieldset-global-section">
                <summary>GlobalGeometry</summary>
                <div class="menu-content">
                  <div class="fieldset-global-grid" id="fieldset-global"></div>
                </div>
              </details>
              <details class="menu-section" id="fieldset-devices-section">
                <summary>Devices</summary>
                <div class="menu-content">
                  <div class="fieldset-actions">
                    <button type="button" class="inline-btn" id="btn-add-fieldset-device">
                      Add Device
                    </button>
                  </div>
                  <div class="fieldsets-editor" id="fieldset-devices"></div>
                </div>
              </details>
              <div class="fieldsets-editor" id="fieldsets-editor"></div>
            
          </div>
        </details>
        
        
        <details class="menu-section" >

          <summary>Export_CasetablesAndCases</summary>
          <div class="menu-content">

              <div class="casetable-section">
                <h3>Configuration</h3>
                <div class="casetable-configuration" id="casetable-configuration"></div>
              </div>
              <div class="casetable-section">
                <div class="casetable-cases-header">
                  <h3>Cases</h3>
                  <button type="button" class="inline-btn" id="btn-add-case">Add Case</button>
                  <span class="casetable-case-count" id="casetable-case-count"></span>
                </div>
                <div class="casetable-cases-list" id="casetable-cases"></div>
                <p class="casetable-help-text">Up to 128 monitoring cases can be defined.</p>
              </div>

          </div>
        </details>
        
        <h2>TriOrb Menu</h2>
        <details class="menu-section">
          <summary>Device</summary>
          <div class="menu-content">
            <div class="menu-fileinfo-grid">
              <div class="triorb-field">
                <label>FieldOfView</label>
                <input
                  type="number"
                  id="triorb-field-of-view"
                  value="270"
                  min="1"
                  max="360"
                  step="1"
                />
              </div>
            </div>
          </div>
        </details>
        <details class="menu-section">
          <summary>Shapes</summary>
          <div class="menu-content">
            <div class="fieldset-actions">
              <button type="button" class="inline-btn" id="btn-add-triorb-shape">
                Add Shape
              </button>
            </div>
            <div class="triorb-shapes-list" id="triorb-shapes-list"></div>
          </div>
        </details>
        <details class="menu-section">
          <summary>Common</summary>
          <div class="menu-content">
            <div class="menu-fileinfo-grid">
              <div class="triorb-field">
                <label>MultipleSampling (2-16)</label>
                <input
                  id="global-multiple-sampling"
                  type="number"
                  min="2"
                  max="16"
                  value="2"
                />
              </div>
              <div class="triorb-field">
                <label>Resolution</label>
                <input
                  id="global-resolution"
                  type="number"
                  min="1"
                  max="1000"
                  value="70"
                />
              </div>
              <div class="triorb-field">
                <label>TolerancePositive</label>
                <input
                  id="global-tolerance-positive"
                  type="number"
                  value="0"
                />
              </div>
              <div class="triorb-field">
                <label>ToleranceNegative</label>
                <input
                  id="global-tolerance-negative"
                  type="number"
                  value="0"
                />
              </div>
            </div>
            <details class="menu-section">
              <summary>CommonCutOut #1</summary>
              <div class="menu-content">
                <ul>
                  <li>Polygon #1</li>
                  <li>Circle #1</li>
                  <li>Rectangle #1</li>
                </ul>
              </div>
            </details>
          </div>
        </details>
      </aside>
    </main>
    <footer>Flask + Plotly powered preview</footer>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const defaultFigure = {"data": [], "layout": {"legend": {"orientation": "h", "y": 1.02, "yanchor": "bottom"}, "margin": {"b": 60, "l": 60, "r": 20, "t": 30}, "paper_bgcolor": "#ffffff", "plot_bgcolor": "#ffffff", "shapes": [{"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -1000, "x1": 1000, "xref": "x", "y0": -750, "y1": -750, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -750, "x1": -750, "xref": "x", "y0": -1000, "y1": 1000, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -1000, "x1": 1000, "xref": "x", "y0": -500, "y1": -500, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -500, "x1": -500, "xref": "x", "y0": -1000, "y1": 1000, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -1000, "x1": 1000, "xref": "x", "y0": -250, "y1": -250, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -250, "x1": -250, "xref": "x", "y0": -1000, "y1": 1000, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -1000, "x1": 1000, "xref": "x", "y0": 250, "y1": 250, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": 250, "x1": 250, "xref": "x", "y0": -1000, "y1": 1000, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -1000, "x1": 1000, "xref": "x", "y0": 500, "y1": 500, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": 500, "x1": 500, "xref": "x", "y0": -1000, "y1": 1000, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -1000, "x1": 1000, "xref": "x", "y0": 750, "y1": 750, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": 750, "x1": 750, "xref": "x", "y0": -1000, "y1": 1000, "yref": "y"}], "template": {"data": {"bar": [{"error_x": {"color": "#2a3f5f"}, "error_y": {"color": "#2a3f5f"}, "marker": {"line": {"color": "#E5ECF6", "width": 0.5}, "pattern": {"fillmode": "overlay", "size": 10, "solidity": 0.2}}, "type": "bar"}], "barpolar": [{"marker": {"line": {"color": "#E5ECF6", "width": 0.5}, "pattern": {"fillmode": "overlay", "size": 10, "solidity": 0.2}}, "type": "barpolar"}], "carpet": [{"aaxis": {"endlinecolor": "#2a3f5f", "gridcolor": "white", "linecolor": "white", "minorgridcolor": "white", "startlinecolor": "#2a3f5f"}, "baxis": {"endlinecolor": "#2a3f5f", "gridcolor": "white", "linecolor": "white", "minorgridcolor": "white", "startlinecolor": "#2a3f5f"}, "type": "carpet"}], "choropleth": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "type": "choropleth"}], "contour": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "colorscale": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]], "type": "contour"}], "contourcarpet": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "type": "contourcarpet"}], "heatmap": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "colorscale": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]], "type": "heatmap"}], "histogram": [{"marker": {"pattern": {"fillmode": "overlay", "size": 10, "solidity": 0.2}}, "type": "histogram"}], "histogram2d": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "colorscale": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]], "type": "histogram2d"}], "histogram2dcontour": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "colorscale": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]], "type": "histogram2dcontour"}], "mesh3d": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "type": "mesh3d"}], "parcoords": [{"line": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "parcoords"}], "pie": [{"automargin": true, "type": "pie"}], "scatter": [{"fillpattern": {"fillmode": "overlay", "size": 10, "solidity": 0.2}, "type": "scatter"}], "scatter3d": [{"line": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scatter3d"}], "scattercarpet": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scattercarpet"}], "scattergeo": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scattergeo"}], "scattergl": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scattergl"}], "scattermap": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scattermap"}], "scattermapbox": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scattermapbox"}], "scatterpolar": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scatterpolar"}], "scatterpolargl": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scatterpolargl"}], "scatterternary": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scatterternary"}], "surface": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "colorscale": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]], "type": "surface"}], "table": [{"cells": {"fill": {"color": "#EBF0F8"}, "line": {"color": "white"}}, "header": {"fill": {"color": "#C8D4E3"}, "line": {"color": "white"}}, "type": "table"}]}, "layout": {"annotationdefaults": {"arrowcolor": "#2a3f5f", "arrowhead": 0, "arrowwidth": 1}, "autotypenumbers": "strict", "coloraxis": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "colorscale": {"diverging": [[0, "#8e0152"], [0.1, "#c51b7d"], [0.2, "#de77ae"], [0.3, "#f1b6da"], [0.4, "#fde0ef"], [0.5, "#f7f7f7"], [0.6, "#e6f5d0"], [0.7, "#b8e186"], [0.8, "#7fbc41"], [0.9, "#4d9221"], [1, "#276419"]], "sequential": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]], "sequentialminus": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]]}, "colorway": ["#636efa", "#EF553B", "#00cc96", "#ab63fa", "#FFA15A", "#19d3f3", "#FF6692", "#B6E880", "#FF97FF", "#FECB52"], "font": {"color": "#2a3f5f"}, "geo": {"bgcolor": "white", "lakecolor": "white", "landcolor": "#E5ECF6", "showlakes": true, "showland": true, "subunitcolor": "white"}, "hoverlabel": {"align": "left"}, "hovermode": "closest", "mapbox": {"style": "light"}, "paper_bgcolor": "white", "plot_bgcolor": "#E5ECF6", "polar": {"angularaxis": {"gridcolor": "white", "linecolor": "white", "ticks": ""}, "bgcolor": "#E5ECF6", "radialaxis": {"gridcolor": "white", "linecolor": "white", "ticks": ""}}, "scene": {"xaxis": {"backgroundcolor": "#E5ECF6", "gridcolor": "white", "gridwidth": 2, "linecolor": "white", "showbackground": true, "ticks": "", "zerolinecolor": "white"}, "yaxis": {"backgroundcolor": "#E5ECF6", "gridcolor": "white", "gridwidth": 2, "linecolor": "white", "showbackground": true, "ticks": "", "zerolinecolor": "white"}, "zaxis": {"backgroundcolor": "#E5ECF6", "gridcolor": "white", "gridwidth": 2, "linecolor": "white", "showbackground": true, "ticks": "", "zerolinecolor": "white"}}, "shapedefaults": {"line": {"color": "#2a3f5f"}}, "ternary": {"aaxis": {"gridcolor": "white", "linecolor": "white", "ticks": ""}, "baxis": {"gridcolor": "white", "linecolor": "white", "ticks": ""}, "bgcolor": "#E5ECF6", "caxis": {"gridcolor": "white", "linecolor": "white", "ticks": ""}}, "title": {"x": 0.05}, "xaxis": {"automargin": true, "gridcolor": "white", "linecolor": "white", "ticks": "", "title": {"standoff": 15}, "zerolinecolor": "white", "zerolinewidth": 2}, "yaxis": {"automargin": true, "gridcolor": "white", "linecolor": "white", "ticks": "", "title": {"standoff": 15}, "zerolinecolor": "white", "zerolinewidth": 2}}}, "xaxis": {"constrain": "range", "dtick": 100, "gridcolor": "#d9dee7", "gridwidth": 1, "linecolor": "#6b7a99", "linewidth": 2, "minor": {"dtick": 50, "gridcolor": "#f2f5fb", "gridwidth": 0.5, "showgrid": true}, "range": [-1000, 1000], "showgrid": true, "showline": true, "tick0": 0, "title": {"text": "X[mm]"}, "zeroline": true, "zerolinecolor": "#9fb3d1", "zerolinewidth": 2}, "yaxis": {"constrain": "range", "dtick": 100, "gridcolor": "#d9dee7", "gridwidth": 1, "linecolor": "#6b7a99", "linewidth": 2, "minor": {"dtick": 50, "gridcolor": "#f2f5fb", "gridwidth": 0.5, "showgrid": true}, "range": [-1000, 1000], "scaleanchor": "x", "scaleratio": 1, "showgrid": true, "showline": true, "tick0": 0, "title": {"text": "Y[mm]"}, "zeroline": true, "zerolinecolor": "#9fb3d1", "zerolinewidth": 2}}};
        defaultFigure.data = defaultFigure.data || [];
        const rootAttributes = {"Commentary": "", "Hash": "0835FD278D7CC3C3C7CF2A2872DA772020A46E3D1E4B6FF93D5FC242CB2EA042CB9F33C38E4006EA160A969DA725A1134AC8FE5A45A87380DBC5C998B757CB5F", "Timestamp": "2025-11-11T01:58:44.6531564Z"};
        const initialScanPlanes = [{"attributes": {"Index": "0", "MultipleSampling": "2", "MultipleSamplingOff2OnActivated": "false", "Name": "Monitoring plane 1", "ObjectSize": "70", "ScanPlaneDirection": "Horizontal", "SelectedCaseSwitching": "Fast", "UseReferenceContour": "false"}, "devices": [{"attributes": {"DeviceName": "Right", "Index": "0", "ResponseTime": "30", "ScanResolutionAddition": "0", "Typekey": "NANS3-CAAZ30ZA1P02", "TypekeyDisplayVersion": "V 1.0.0", "TypekeyVersion": "1.0"}}]}];
        const fieldsetData = {"devices": [{"attributes": {"PositionX": "170", "PositionY": "156", "Rotation": "290", "StandingUpsideDown": "true", "Typekey": "NANS3-CAAZ30ZA1P02", "TypekeyDisplayVersion": "V 1.0.0", "TypekeyVersion": "1.0"}}], "fieldsets": [{"attributes": {"Name": "\u53f30.65", "NameLatin9Key": "_FSN000_9516"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-a0cf782e"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-ce8cb225"}]}]}, {"attributes": {"Name": "\u53f3\u524d0.65", "NameLatin9Key": "_FSN001_2740"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-a74436a8"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-7e844a0d"}]}]}, {"attributes": {"Name": "\u524d0.65", "NameLatin9Key": "_FSN002_363F"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-c1922699"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-9ac47d6a"}]}]}, {"attributes": {"Name": "\u5de6\u524d0.65", "NameLatin9Key": "_FSN003_D5B2"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-a5cff1cd"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-d3704ab3"}]}]}, {"attributes": {"Name": "\u5de60.65", "NameLatin9Key": "_FSN004_EE1F"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-ac43285c"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-6961448d"}]}]}, {"attributes": {"Name": "\u5de6\u5f8c0.65", "NameLatin9Key": "_FSN005_528B"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-893f9bbb"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-3f637e22"}]}]}, {"attributes": {"Name": "\u5f8c0.65", "NameLatin9Key": "_FSN006_B106"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-68016821"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-e60cd506"}]}]}, {"attributes": {"Name": "\u53f3\u5f8c0.65", "NameLatin9Key": "_FSN007_A079"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-5bf508b2"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-7bae92f0"}]}]}, {"attributes": {"Name": "\u53f30.3", "NameLatin9Key": "_FSN008_D438"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-d42c017e"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-6c08b469"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-d2d33732"}]}]}, {"attributes": {"Name": "\u53f3\u524d0.3", "NameLatin9Key": "_FSN009_4381"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-6dc064a4"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-96302e4a"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-28c82220"}]}]}, {"attributes": {"Name": "\u524d0.3", "NameLatin9Key": "_FSN010_3CBD"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-6c7dcf0c"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-f1f8e7ec"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-a3cd07f4"}]}]}, {"attributes": {"Name": "\u5de6\u524d0.3", "NameLatin9Key": "_FSN011_30C7"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-4d998f65"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-b5052a8a"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-3f30982d"}]}]}, {"attributes": {"Name": "\u5de60.3", "NameLatin9Key": "_FSN012_1D9D"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-6d6e5536"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-147eb446"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-839cff8b"}]}]}, {"attributes": {"Name": "\u5de6\u5f8c0.3", "NameLatin9Key": "_FSN013_0833"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-3608b9db"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-6658247d"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-3917624b"}]}]}, {"attributes": {"Name": "\u5f8c0.3", "NameLatin9Key": "_FSN014_0449"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-011b748c"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-0ca97f3f"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-d3559519"}]}]}, {"attributes": {"Name": "\u53f3\u5f8c0.3", "NameLatin9Key": "_FSN015_7B75"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-ffbdf4d7"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-02c93537"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-43d7c4b2"}]}]}, {"attributes": {"Name": "\u53f30.15", "NameLatin9Key": "_FSN016_A514"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-f5cde190"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-968bfc3d"}]}]}, {"attributes": {"Name": "\u53f3\u524d0.15", "NameLatin9Key": "_FSN017_1742"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-7cb65d29"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-0c82138a"}]}]}, {"attributes": {"Name": "\u524d0.15", "NameLatin9Key": "_FSN018_063D"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-b2c7ee4b"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-65172861"}]}]}, {"attributes": {"Name": "\u5de6\u524d0.15", "NameLatin9Key": "_FSN019_E5B0"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-9e9a0ad5"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-18d51a7c"}]}]}, {"attributes": {"Name": "\u5de60.15", "NameLatin9Key": "_FSN020_DE1D"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-9f15db80"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-721e99e7"}]}]}, {"attributes": {"Name": "\u5de6\u5f8c0.15", "NameLatin9Key": "_FSN021_6289"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-06401945"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-0c7bed21"}]}]}, {"attributes": {"Name": "\u5f8c0.15", "NameLatin9Key": "_FSN022_8104"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-ca3a47c4"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-6775565f"}]}]}, {"attributes": {"Name": "\u53f3\u5f8c0.15", "NameLatin9Key": "_FSN023_907B"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-fd204bea"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-f07c92db"}]}]}, {"attributes": {"Name": "\u56de\u8ee2", "NameLatin9Key": "_FSN024_7C2F"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-e579f9ce"}, {"shapeId": "shape-9b230cc4"}]}]}, {"attributes": {"Name": "Stop(minimum)"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "4", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-7ab37b41"}, {"shapeId": "shape-2e2c7edc"}, {"shapeId": "shape-e338d649"}, {"shapeId": "shape-f9ab7733"}, {"shapeId": "shape-c56161ab"}, {"shapeId": "shape-faa9b302"}]}]}], "global_geometry": {"UseGlobalGeometry": "false"}};
        const initialFieldsets = fieldsetData.fieldsets || [];
        const initialFieldsetDevices = fieldsetData.devices || [];
        const initialFieldsetGlobal = fieldsetData.global_geometry || {};
        const casetablePayload = {
          casetable_attributes: { Index: "0" },
          configuration: null,
          cases: [],
          evals: null,
          fields_configuration: null,
          layout: [
            { kind: "configuration" },
            { kind: "cases" },
            { kind: "evals" },
            { kind: "fields_configuration" },
          ],
        };

        const figureConfig = { responsive: true, displaylogo: false };
        const fieldsetColorPalette = [
          "#2563eb",
          "#f43f5e",
          "#10b981",
          "#f97316",
          "#c084fc",
          "#14b8a6",
          "#facc15",
          "#8b5cf6",
        ];
        const circleSampleSegments = 72;
        const legendLabelMaxLength = 36;
        const defaultScanDeviceTemplates = [
          { DeviceName: "Right" },
          { DeviceName: "Left" },
        ];
        const defaultFieldsetDeviceTemplates = [
          {
            DeviceName: "Right",
            PositionX: "170",
            PositionY: "156",
            Rotation: "290",
            StandingUpsideDown: "true",
          },
          {
            DeviceName: "Left",
            PositionX: "-170",
            PositionY: "156",
            Rotation: "70",
            StandingUpsideDown: "true",
          },
        ];
        const shapeTypeOptions = {
          polygon: ["CutOut", "Field"],
          rectangle: ["Field"],
          circle: ["Field"],
        };
        const fieldTypeColorScales = {
          ProtectiveSafeBlanking: [
            "#fcf3cf",
            "#f9e79f",
            "#f7dc6f",
            "#f4d03f",
            "#f1c40f",
          ],
          WarningSafeBlanking: [
            "#f7fbff",
            "#deebf7",
            "#c6dbef",
            "#6baed6",
            "#2171b5",
          ],
        };
        const triOrbColorScale = [
          "#f4f5f7",
          "#d9e3f0",
          "#b4c1d8",
          "#6e7c8b",
          "#2f3d49",
        ];
        function sampleColorFromScale(scale, index, total = 1) {
          if (!Array.isArray(scale) || !scale.length) {
            return "#888";
          }
          const steps = Math.max(total - 1, 1);
          const ratio = Math.min(scale.length - 1, Math.floor((index / steps) * (scale.length - 1)));
          return scale[ratio];
        }
        function pickFieldColor(fieldType, shapeIndex, totalShapes) {
          const scale =
            fieldTypeColorScales[fieldType] || fieldTypeColorScales.ProtectiveSafeBlanking;
          return sampleColorFromScale(scale, shapeIndex, totalShapes);
        }
        function pickTriOrbColor(shapeIndex) {
          return sampleColorFromScale(triOrbColorScale, shapeIndex, triorbShapes.length || 1);
        }
        const plotNode = document.getElementById("plot");
        const statusText = document.getElementById("status-text");
        const fileInput = document.getElementById("file-input");
        const plotWrapper = document.querySelector(".plot-wrapper");
        const scanPlanesContainer = document.getElementById("scanplanes-editor");
        const addScanPlaneBtn = document.getElementById("btn-add-scanplane");
        const fieldsetsContainer = document.getElementById("fieldsets-editor");
        const fieldsetDevicesContainer = document.getElementById("fieldset-devices");
        const addFieldsetDeviceBtn = document.getElementById("btn-add-fieldset-device");
        const fieldsetGlobalContainer = document.getElementById("fieldset-global");
        const addFieldsetBtn = document.getElementById("btn-add-fieldset");
        const globalMultipleSamplingInput = document.getElementById("global-multiple-sampling");
        const fieldsetCheckboxes = document.getElementById("fieldset-checkboxes");
        if (fieldsetCheckboxes) {
          fieldsetCheckboxes.classList.add("toggle-pill-grid");
        }
        const casetableConfigurationContainer = document.getElementById("casetable-configuration");
        const casetableCasesContainer = document.getElementById("casetable-cases");
        const casetableCaseCountLabel = document.getElementById("casetable-case-count");
        const addCasetableCaseBtn = document.getElementById("btn-add-case");
        const checkAllBtn = document.getElementById("btn-fieldset-check-all");
        const uncheckAllBtn = document.getElementById("btn-fieldset-uncheck-all");
        const toggleLegendBtn = document.getElementById("btn-toggle-legend");
        const fieldOfViewInput = document.getElementById("triorb-field-of-view");
        const globalResolutionInput = document.getElementById("global-resolution");
        const globalTolerancePositiveInput = document.getElementById("global-tolerance-positive");
        const globalToleranceNegativeInput = document.getElementById("global-tolerance-negative");
        const triorbShapesContainer = document.getElementById("triorb-shapes-list");
        const addTriOrbShapeBtn = document.getElementById("btn-add-triorb-shape");
        const triorbShapeCheckboxes = document.getElementById("triorb-shape-checkboxes");
        if (triorbShapeCheckboxes) {
          triorbShapeCheckboxes.classList.add("toggle-pill-grid");
        }
        const triorbShapeCheckAllBtn = document.getElementById("btn-triorb-shape-check-all");
        const triorbShapeUncheckAllBtn = document.getElementById("btn-triorb-shape-uncheck-all");
        let globalMultipleSampling = "2";
        const initialTriOrbShapes = [{"fieldtype": "ProtectiveSafeBlanking", "id": "shape-e579f9ce", "kind": "CutOut", "name": "\u53f30.65 Protective Polygon", "polygon": {"Type": "CutOut", "points": [{"X": "0", "Y": "245"}, {"X": "170", "Y": "156"}, {"X": "0", "Y": "-299"}, {"X": "-170", "Y": "156"}]}, "type": "Polygon"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-a0cf782e", "kind": "Field", "name": "\u53f30.65 Protective Rectangle", "rectangle": {"Height": "924", "OriginX": "-200", "OriginY": "464", "Rotation": "0", "Type": "Field", "Width": "950"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-ce8cb225", "kind": "Field", "name": "\u53f30.65 Speed down Rectangle", "rectangle": {"Height": "1024", "OriginX": "-200", "OriginY": "512", "Rotation": "0", "Type": "Field", "Width": "1600"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-a74436a8", "kind": "Field", "name": "\u53f3\u524d0.65 Protective Rectangle", "rectangle": {"Height": "924", "OriginX": "-325", "OriginY": "329", "Rotation": "45", "Type": "Field", "Width": "826"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-7e844a0d", "kind": "Field", "name": "\u53f3\u524d0.65 Speed down Rectangle", "rectangle": {"Height": "1024", "OriginX": "-361", "OriginY": "363", "Rotation": "45", "Type": "Field", "Width": "1474"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-c1922699", "kind": "Field", "name": "\u524d0.65 Protective Rectangle", "rectangle": {"Height": "950", "OriginX": "-462", "OriginY": "750", "Rotation": "0", "Type": "Field", "Width": "924"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-9ac47d6a", "kind": "Field", "name": "\u524d0.65 Speed down Rectangle", "rectangle": {"Height": "1600", "OriginX": "-512", "OriginY": "1400", "Rotation": "0", "Type": "Field", "Width": "1024"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-a5cff1cd", "kind": "Field", "name": "\u5de6\u524d0.65 Protective Rectangle", "rectangle": {"Height": "924", "OriginX": "-268", "OriginY": "916", "Rotation": "315", "Type": "Field", "Width": "839"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-d3704ab3", "kind": "Field", "name": "\u5de6\u524d0.65 Speed down Rectangle", "rectangle": {"Height": "1024", "OriginX": "-682", "OriginY": "1404", "Rotation": "315", "Type": "Field", "Width": "1477"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-ac43285c", "kind": "Field", "name": "\u5de60.65 Protective Rectangle", "rectangle": {"Height": "924", "OriginX": "-750", "OriginY": "462", "Rotation": "0", "Type": "Field", "Width": "950"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-6961448d", "kind": "Field", "name": "\u5de60.65 Speed down Rectangle", "rectangle": {"Height": "1024", "OriginX": "-1400", "OriginY": "512", "Rotation": "0", "Type": "Field", "Width": "1600"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-893f9bbb", "kind": "Field", "name": "\u5de6\u5f8c0.65 Protective Rectangle", "rectangle": {"Height": "924", "OriginX": "-916", "OriginY": "-262", "Rotation": "45", "Type": "Field", "Width": "833"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-3f637e22", "kind": "Field", "name": "\u5de6\u5f8c0.65 Speed down Rectangle", "rectangle": {"Height": "1024", "OriginX": "-1407", "OriginY": "-687", "Rotation": "45", "Type": "Field", "Width": "1481"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-68016821", "kind": "Field", "name": "\u5f8c0.65 Protective Rectangle", "rectangle": {"Height": "950", "OriginX": "-462", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "924"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-e60cd506", "kind": "Field", "name": "\u5f8c0.65 Speed down Rectangle", "rectangle": {"Height": "1600", "OriginX": "-512", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "1024"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-5bf508b2", "kind": "Field", "name": "\u53f3\u5f8c0.65 Protective Rectangle", "rectangle": {"Height": "924", "OriginX": "325", "OriginY": "325", "Rotation": "315", "Type": "Field", "Width": "830"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-7bae92f0", "kind": "Field", "name": "\u53f3\u5f8c0.65 Speed down Rectangle", "rectangle": {"Height": "1024", "OriginX": "361", "OriginY": "361", "Rotation": "315", "Type": "Field", "Width": "1486"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-d42c017e", "kind": "Field", "name": "\u53f30.3 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-200", "OriginY": "362", "Rotation": "0", "Type": "Field", "Width": "750"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-6c08b469", "kind": "Field", "name": "\u53f30.3 Speed down Rectangle", "rectangle": {"Height": "824", "OriginX": "-200", "OriginY": "412", "Rotation": "0", "Type": "Field", "Width": "1200"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-d2d33732", "kind": "Field", "name": "\u53f30.3 Speed up Rectangle", "rectangle": {"Height": "1124", "OriginX": "-200", "OriginY": "562", "Rotation": "0", "Type": "Field", "Width": "1700"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-6dc064a4", "kind": "Field", "name": "\u53f3\u524d0.3 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-257", "OriginY": "257", "Rotation": "45", "Type": "Field", "Width": "634"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-96302e4a", "kind": "Field", "name": "\u53f3\u524d0.3 Speed down Rectangle", "rectangle": {"Height": "824", "OriginX": "-291", "OriginY": "291", "Rotation": "45", "Type": "Field", "Width": "1078"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-28c82220", "kind": "Field", "name": "\u53f3\u524d0.3 Speed up Rectangle", "rectangle": {"Height": "1124", "OriginX": "-396", "OriginY": "396", "Rotation": "45", "Type": "Field", "Width": "1579"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-6c7dcf0c", "kind": "Field", "name": "\u524d0.3 Protective Rectangle", "rectangle": {"Height": "750", "OriginX": "-362", "OriginY": "550", "Rotation": "0", "Type": "Field", "Width": "724"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-f1f8e7ec", "kind": "Field", "name": "\u524d0.3 Speed down Rectangle", "rectangle": {"Height": "1200", "OriginX": "-412", "OriginY": "1000", "Rotation": "0", "Type": "Field", "Width": "824"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-a3cd07f4", "kind": "Field", "name": "\u524d0.3 Speed up Rectangle", "rectangle": {"Height": "1700", "OriginX": "-562", "OriginY": "1500", "Rotation": "0", "Type": "Field", "Width": "1124"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-4d998f65", "kind": "Field", "name": "\u5de6\u524d0.3 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-195", "OriginY": "705", "Rotation": "315", "Type": "Field", "Width": "635"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-b5052a8a", "kind": "Field", "name": "\u5de6\u524d0.3 Speed down Rectangle", "rectangle": {"Height": "824", "OriginX": "-456", "OriginY": "1040", "Rotation": "315", "Type": "Field", "Width": "1058"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-3f30982d", "kind": "Field", "name": "\u5de6\u524d0.3 Speed up Rectangle", "rectangle": {"Height": "1124", "OriginX": "-629", "OriginY": "1421", "Rotation": "315", "Type": "Field", "Width": "1451"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-6d6e5536", "kind": "Field", "name": "\u5de60.3 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-550", "OriginY": "362", "Rotation": "0", "Type": "Field", "Width": "750"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-147eb446", "kind": "Field", "name": "\u5de60.3 Speed down Rectangle", "rectangle": {"Height": "824", "OriginX": "-1000", "OriginY": "412", "Rotation": "0", "Type": "Field", "Width": "1200"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-839cff8b", "kind": "Field", "name": "\u5de60.3 Speed up Rectangle", "rectangle": {"Height": "1124", "OriginX": "-1500", "OriginY": "562", "Rotation": "0", "Type": "Field", "Width": "1700"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-3608b9db", "kind": "Field", "name": "\u5de6\u5f8c0.3 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-699", "OriginY": "-191", "Rotation": "45", "Type": "Field", "Width": "629"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-6658247d", "kind": "Field", "name": "\u5de6\u5f8c0.3 Speed down Rectangle", "rectangle": {"Height": "824", "OriginX": "-1058", "OriginY": "-474", "Rotation": "45", "Type": "Field", "Width": "1084"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-3917624b", "kind": "Field", "name": "\u5de6\u5f8c0.3 Speed up Rectangle", "rectangle": {"Height": "1124", "OriginX": "-1519", "OriginY": "-721", "Rotation": "45", "Type": "Field", "Width": "1585"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-011b748c", "kind": "Field", "name": "\u5f8c0.3 Protective Rectangle", "rectangle": {"Height": "750", "OriginX": "-362", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "724"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-0ca97f3f", "kind": "Field", "name": "\u5f8c0.3 Speed down Rectangle", "rectangle": {"Height": "1200", "OriginX": "-412", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "824"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-d3559519", "kind": "Field", "name": "\u5f8c0.3 Speed up Rectangle", "rectangle": {"Height": "1700", "OriginX": "-562", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "1124"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-ffbdf4d7", "kind": "Field", "name": "\u53f3\u5f8c0.3 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "259", "OriginY": "255", "Rotation": "315", "Type": "Field", "Width": "634"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-02c93537", "kind": "Field", "name": "\u53f3\u5f8c0.3 Speed down Rectangle", "rectangle": {"Height": "824", "OriginX": "294", "OriginY": "290", "Rotation": "315", "Type": "Field", "Width": "1072"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-43d7c4b2", "kind": "Field", "name": "\u53f3\u5f8c0.3 Speed up Rectangle", "rectangle": {"Height": "1024", "OriginX": "361", "OriginY": "361", "Rotation": "315", "Type": "Field", "Width": "1575"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-f5cde190", "kind": "Field", "name": "\u53f30.15 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-200", "OriginY": "362", "Rotation": "0", "Type": "Field", "Width": "700"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-968bfc3d", "kind": "Field", "name": "\u53f30.15 Speed up Rectangle", "rectangle": {"Height": "924", "OriginX": "-200", "OriginY": "462", "Rotation": "0", "Type": "Field", "Width": "1300"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-7cb65d29", "kind": "Field", "name": "\u53f3\u524d0.15 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-255", "OriginY": "259", "Rotation": "45", "Type": "Field", "Width": "585"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-0c82138a", "kind": "Field", "name": "\u53f3\u524d0.15 Speed up Rectangle", "rectangle": {"Height": "924", "OriginX": "-324", "OriginY": "324", "Rotation": "45", "Type": "Field", "Width": "1183"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-b2c7ee4b", "kind": "Field", "name": "\u524d0.15 Protective Rectangle", "rectangle": {"Height": "700", "OriginX": "-362", "OriginY": "500", "Rotation": "0", "Type": "Field", "Width": "724"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-65172861", "kind": "Field", "name": "\u524d0.15 Speed up Rectangle", "rectangle": {"Height": "1300", "OriginX": "-462", "OriginY": "1100", "Rotation": "0", "Type": "Field", "Width": "924"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-9e9a0ad5", "kind": "Field", "name": "\u5de6\u524d0.15 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-158", "OriginY": "668", "Rotation": "315", "Type": "Field", "Width": "585"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-18d51a7c", "kind": "Field", "name": "\u5de6\u524d0.15 Speed up Rectangle", "rectangle": {"Height": "924", "OriginX": "-509", "OriginY": "1167", "Rotation": "315", "Type": "Field", "Width": "1187"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-9f15db80", "kind": "Field", "name": "\u5de60.15 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-500", "OriginY": "362", "Rotation": "0", "Type": "Field", "Width": "700"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-721e99e7", "kind": "Field", "name": "\u5de60.15 Speed up Rectangle", "rectangle": {"Height": "924", "OriginX": "-1100", "OriginY": "462", "Rotation": "0", "Type": "Field", "Width": "1300"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-06401945", "kind": "Field", "name": "\u5de6\u5f8c0.15 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-666", "OriginY": "-158", "Rotation": "45", "Type": "Field", "Width": "587"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-0c7bed21", "kind": "Field", "name": "\u5de6\u5f8c0.15 Speed up Rectangle", "rectangle": {"Height": "924", "OriginX": "-1159", "OriginY": "-503", "Rotation": "45", "Type": "Field", "Width": "1177"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-ca3a47c4", "kind": "Field", "name": "\u5f8c0.15 Protective Rectangle", "rectangle": {"Height": "700", "OriginX": "-362", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "724"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-6775565f", "kind": "Field", "name": "\u5f8c0.15 Speed up Rectangle", "rectangle": {"Height": "1300", "OriginX": "-462", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "924"}, "type": "Rectangle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-fd204bea", "kind": "Field", "name": "\u53f3\u5f8c0.15 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "257", "OriginY": "257", "Rotation": "315", "Type": "Field", "Width": "586"}, "type": "Rectangle"}, {"fieldtype": "WarningSafeBlanking", "id": "shape-f07c92db", "kind": "Field", "name": "\u53f3\u5f8c0.15 Speed up Rectangle", "rectangle": {"Height": "1024", "OriginX": "362", "OriginY": "360", "Rotation": "315", "Type": "Field", "Width": "1180"}, "type": "Rectangle"}, {"circle": {"CenterX": "0", "CenterY": "0", "Radius": "542", "Type": "Field"}, "fieldtype": "ProtectiveSafeBlanking", "id": "shape-9b230cc4", "kind": "Field", "name": "\u56de\u8ee2 Protective Circle", "type": "Circle"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-7ab37b41", "kind": "Field", "name": "Stop(minimum) Protective Polygon", "polygon": {"Type": "Field", "points": [{"X": "-245", "Y": "86"}, {"X": "-98", "Y": "-161"}, {"X": "98", "Y": "-163"}, {"X": "240", "Y": "79"}, {"X": "139", "Y": "250"}, {"X": "-137", "Y": "247"}]}, "type": "Polygon"}, {"fieldtype": "ProtectiveSafeBlanking", "id": "shape-2e2c7edc", "kind": "CutOut", "name": "Stop(minimum) Protective Polygon", "polygon": {"Type": "CutOut", "points": [{"X": "-173", "Y": "160"}, {"X": "-1", "Y": "227"}, {"X": "165", "Y": "157"}, {"X": "0", "Y": "-242"}]}, "type": "Polygon"}, {"circle": {"CenterX": "-1", "CenterY": "-163", "Radius": "1", "Type": "Field"}, "fieldtype": "ProtectiveSafeBlanking", "id": "shape-e338d649", "kind": "Field", "name": "Stop(minimum) Protective Circle", "type": "Circle"}, {"circle": {"CenterX": "0", "CenterY": "-167", "Radius": "99", "Type": "Field"}, "fieldtype": "ProtectiveSafeBlanking", "id": "shape-f9ab7733", "kind": "Field", "name": "Stop(minimum) Protective Circle", "type": "Circle"}, {"circle": {"CenterX": "-190", "CenterY": "166", "Radius": "99", "Type": "Field"}, "fieldtype": "ProtectiveSafeBlanking", "id": "shape-c56161ab", "kind": "Field", "name": "Stop(minimum) Protective Circle", "type": "Circle"}, {"circle": {"CenterX": "188", "CenterY": "164", "Radius": "99", "Type": "Field"}, "fieldtype": "ProtectiveSafeBlanking", "id": "shape-faa9b302", "kind": "Field", "name": "Stop(minimum) Protective Circle", "type": "Circle"}];
        const shapeModal = document.getElementById("shape-modal");
        const shapeModalBody = document.getElementById("shape-modal-body");
        const shapeModalTitle = document.getElementById("shape-modal-title");
        const shapeModalSave = document.getElementById("shape-modal-save");
        const shapeModalCancel = document.getElementById("shape-modal-cancel");
        const shapeModalClose = document.getElementById("shape-modal-close");
        const shapeModalWindow = document.querySelector("#shape-modal .modal-window");
        const shapeModalHeader = shapeModalWindow?.querySelector(".modal-header");
        const createShapeModal = document.getElementById("create-shape-modal");
        const createShapeModalWindow = document.querySelector("#create-shape-modal .modal-window");
        const createShapeModalClose = document.getElementById("create-shape-modal-close");
        const createShapeModalCancel = document.getElementById("create-shape-modal-cancel");
        const createShapeModalHeader = createShapeModalWindow?.querySelector(".modal-header");
        const createShapeModalSave = document.getElementById("create-shape-modal-save");
        const createShapeNameInput = document.getElementById("create-shape-name");
        const createShapeFieldtypeSelect = document.getElementById("create-shape-fieldtype");
        const createShapeTypeSelect = document.getElementById("create-shape-type");
        const createShapeKindSelect = document.getElementById("create-shape-kind");
        const createShapePointsInput = document.getElementById("create-shape-points");
        const createShapePolygonGroup = document.querySelector(".shape-polygon-group");
        const createShapeRectFields = document.querySelector(".shape-rectangle-group");
        const createShapeCircleFields = document.querySelector(".shape-circle-group");
        const createShapeFieldsetList = document.getElementById("create-shape-fieldset-list");
        const createRectOriginXInput = document.getElementById("create-rect-originx");
        const createRectOriginYInput = document.getElementById("create-rect-originy");
        const createRectWidthInput = document.getElementById("create-rect-width");
        const createRectHeightInput = document.getElementById("create-rect-height");
        const createRectRotationInput = document.getElementById("create-rect-rotation");
        const createCircleCenterXInput = document.getElementById("create-circle-centerx");
        const createCircleCenterYInput = document.getElementById("create-circle-centery");
        const createCircleRadiusInput = document.getElementById("create-circle-radius");
        const saveTriOrbBtn = document.getElementById("btn-save-triorb");
        const saveSickBtn = document.getElementById("btn-save-sick");
        const newPlotBtn = document.getElementById("btn-new");
        const originTrace = findOriginTrace(defaultFigure);

        let currentFigure = cloneFigure(defaultFigure);
        let scanPlanes = initializeScanPlanes(initialScanPlanes);
        let triorbShapes = initializeTriOrbShapes(initialTriOrbShapes);
        let triorbSource = "";
        let fieldsets = initializeFieldsets(initialFieldsets);
        let fieldsetDevices = initializeFieldsetDevices(initialFieldsetDevices);
        let fieldsetGlobalGeometry = initializeGlobalGeometry(initialFieldsetGlobal);
        const casetableCasesLimit = 128;
        let casetableAttributes = cloneAttributes(
          casetablePayload?.casetable_attributes || { Index: "0" }
        );
        let casetableConfiguration = normalizeCasetableConfiguration(
          casetablePayload?.configuration
        );
        let casetableCases = initializeCasetableCases(casetablePayload?.cases);
        let casetableLayout = normalizeCasetableLayout(casetablePayload?.layout);
        let casetableEvals = cloneGenericNode(casetablePayload?.evals);
        let casetableFieldsConfiguration = cloneGenericNode(
          casetablePayload?.fields_configuration
        );
        globalMultipleSampling = deriveInitialMultipleSampling(fieldsets);
        let legendVisible = true;
        let fieldOfViewDegrees = parseNumeric(fieldOfViewInput?.value, 270);
        const debugMode = Boolean(new URLSearchParams(window.location.search).get("debug"));
        if (debugMode) {
          document.body.classList.add("debug-mode");
        }
        let globalResolution = parseNumeric(globalResolutionInput?.value, 70);
        let globalTolerancePositive = parseNumeric(globalTolerancePositiveInput?.value, 0);
        let globalToleranceNegative = parseNumeric(globalToleranceNegativeInput?.value, 0);
        globalResolution = deriveFieldAttribute(fieldsets, "Resolution", globalResolution);
        globalTolerancePositive = deriveFieldAttribute(fieldsets, "TolerancePositive", globalTolerancePositive);
        globalToleranceNegative = deriveFieldAttribute(fieldsets, "ToleranceNegative", globalToleranceNegative);
        applyGlobalMultipleSampling(globalMultipleSampling, { rerender: false });
        if (globalMultipleSamplingInput) {
          globalMultipleSamplingInput.value = globalMultipleSampling;
        }
        if (globalResolutionInput) {
          globalResolutionInput.value = globalResolution;
        }
        if (globalTolerancePositiveInput) {
          globalTolerancePositiveInput.value = globalTolerancePositive;
        }
        if (globalToleranceNegativeInput) {
          globalToleranceNegativeInput.value = globalToleranceNegative;
        }
        let createShapePreview = null;
        let createShapeDraftId = null;
          updateGlobalFieldAttributes();

          let lastHoverPoint = null;
        let modalShapeMeta = null;
        let modalOriginalShape = null;
        let modalOffsetX = 0;
        let modalOffsetY = 0;
        let modalDragStartX = 0;
        let modalDragStartY = 0;
        let isModalDragging = false;

        renderScanPlanes();
        renderFieldsets();
        renderFieldsetDevices();
        renderFieldsetGlobal();
        renderFieldsetCheckboxes();
        renderTriOrbShapes();
        renderTriOrbShapeCheckboxes();
        renderCasetableConfiguration();
        renderCasetableCases();

        function initializeScanPlanes(data) {
          let planes;
          if (!Array.isArray(data) || !data.length) {
            planes = [createDefaultScanPlane(0)];
          } else {
            planes = data.map((plane, index) => ({
              attributes: { ...(plane.attributes || {}), Index: plane.attributes?.Index ?? String(index) },
              devices: Array.isArray(plane.devices)
                ? plane.devices.map((device, dIdx) => ({
                    attributes: { ...(device.attributes || {}), Index: device.attributes?.Index ?? String(dIdx) },
                  }))
                : [],
            }));
          }
          planes.forEach(ensureDefaultScanDevices);
          return planes;
        }

        function cloneFigure(figure) {
          return JSON.parse(JSON.stringify(figure));
        }

        function setStatus(message, state = "ok") {
          statusText.textContent = message;
          const resolvedState =
            typeof state === "string" ? state : state ? "error" : "ok";
          statusText.dataset.state = resolvedState;
        }

        function renderFigure() {
          syncPlotSize();
          const baseData = (currentFigure.data || []).map((trace, index) => {
            const copy = { ...trace };
            const originalName = copy.name || `Trace ${index + 1}`;
            copy.name = formatLegendLabel(originalName);
            return copy;
          });
          const triOrbShapeTraces = buildTriOrbShapeTraces();
          const overlayTraces = buildFieldsetTraces();
          const previewTraces = buildCreateShapePreviewTraces();
          const layout = {
            ...(currentFigure.layout || {}),
            showlegend: legendVisible,
            legend: {
              ...(currentFigure.layout?.legend || {}),
              x: 0,
              y: 1,
              xanchor: "left",
              yanchor: "top",
              orientation: "v",
              bgcolor: "rgba(255, 255, 255, 0.88)",
              borderwidth: 0,
              font: {
                ...(currentFigure.layout?.legend?.font || {}),
                size: 11,
                color: "#0f172a",
              },
            },
            xaxis: {
              ...(currentFigure.layout?.xaxis || {}),
              title: "",
            },
            yaxis: {
              ...(currentFigure.layout?.yaxis || {}),
              title: "",
            },
          };
          Plotly.react(
            plotNode,
            triOrbShapeTraces.concat(baseData).concat(overlayTraces).concat(previewTraces),
            layout,
            figureConfig
          );
        }

        function buildFieldsetTraces() {
          const deviceTraces = buildDeviceOverlayTraces();
          if (!Array.isArray(fieldsets) || !fieldsets.length) {
            return deviceTraces;
          }
          const traces = [];
          fieldsets.forEach((fieldset, fieldsetIndex) => {
            if (!fieldset || fieldset.visible === false) {
              return;
            }
            const fieldsetName =
              fieldset.attributes?.Name || `Fieldset ${fieldsetIndex + 1}`;
            (fieldset.fields || []).forEach((field, fieldIndex) => {
              const fieldName =
                field.attributes?.Name || `Field ${fieldIndex + 1}`;
              const labelPrefix = `${fieldsetName} / ${fieldName}`;
              const fieldType = field.attributes?.Fieldtype || "ProtectiveSafeBlanking";
              (field.shapeRefs || []).forEach((shapeRef, shapeRefIndex) => {
                const shapeIndex = triorbShapes.findIndex(
                  (item) => item.id === shapeRef.shapeId
                );
                if (shapeIndex < 0) {
                  return;
                }
                const shape = triorbShapes[shapeIndex];
                if (!shape) {
                  return;
                }
                const shapeLabel = `${labelPrefix} / ${shape.name || shape.type}`;
                const color = pickFieldColor(fieldType, shapeRefIndex, field.shapeRefs?.length || 1);
                let shapeTrace = null;
                switch (shape.type) {
                  case "Rectangle":
                    if (shape.rectangle) {
                      shapeTrace = buildRectangleTrace(
                        shape.rectangle,
                        pickFieldColor(fieldType, shapeRefIndex, field.shapeRefs?.length || 1),
                        shapeLabel,
                        fieldType,
                        fieldsetIndex,
                        fieldIndex,
                        shapeRefIndex
                      );
                    }
                    break;
                  case "Circle":
                    if (shape.circle) {
                      shapeTrace = buildCircleTrace(
                        shape.circle,
                        pickFieldColor(fieldType, shapeRefIndex, field.shapeRefs?.length || 1),
                        shapeLabel,
                        fieldType,
                        fieldsetIndex,
                        fieldIndex,
                        shapeRefIndex
                      );
                    }
                    break;
                  case "Polygon":
                  default:
                    if (shape.polygon) {
                      shapeTrace = buildPolygonTrace(
                        shape.polygon,
                        pickFieldColor(fieldType, shapeRefIndex, field.shapeRefs?.length || 1),
                        shapeLabel,
                        fieldType,
                        fieldsetIndex,
                        fieldIndex,
                        shapeRefIndex
                      );
                    }
                    break;
                }
                if (shapeTrace) {
                  shapeTrace.name = formatLegendLabel(shapeLabel);
                  shapeTrace.meta = {
                    ...shapeTrace.meta,
                    isTriOrbShape: true,
                    shapeId: shape.id,
                    shapeIndex,
                    shapeType: shape.type,
                  };
                  traces.push(shapeTrace);
                }
              });
            });
          });
          return deviceTraces.concat(traces);
        }

        function buildCreateShapePreviewTraces() {
          if (!createShapePreview) {
            return [];
          }
          const preview = createShapePreview;
          let previewTrace = null;
          const previewLabel = `${preview.name || "New Shape"} (preview)`;
          switch (preview.type) {
            case "Rectangle":
              previewTrace = buildRectangleTrace(
                preview.rectangle,
                "#ef4444",
                previewLabel,
                preview.fieldtype || "ProtectiveSafeBlanking",
                0,
                0,
                0
              );
              break;
            case "Circle":
              previewTrace = buildCircleTrace(
                preview.circle,
                "#ef4444",
                previewLabel,
                preview.fieldtype || "ProtectiveSafeBlanking",
                0,
                0,
                0
              );
              break;
            case "Polygon":
            default:
              previewTrace = buildPolygonTrace(
                preview.polygon,
                "#ef4444",
                previewLabel,
                preview.fieldtype || "ProtectiveSafeBlanking",
                0,
                0,
                0
              );
              break;
          }
          if (!previewTrace) {
            return [];
          }
          previewTrace.line = {
            ...(previewTrace.line || {}),
            color: "#ef4444",
            width: Math.max((previewTrace.line && previewTrace.line.width) || 2, 3),
            dash: "solid",
          };
          previewTrace.fillcolor = withAlpha("#ef4444", 0.08);
          previewTrace.name = previewLabel;
          previewTrace.showlegend = false;
          previewTrace.hovertemplate = `<b>Preview:</b> ${escapeHtml(
            preview.name || "Shape"
          )}<extra></extra>`;
          previewTrace.meta = { ...(previewTrace.meta || {}), preview: true };
          return [previewTrace];
        }

        function buildPolygonTrace(polygon, color, label, fieldType, fieldsetIndex, fieldIndex, polygonIndex) {
          const points = Array.isArray(polygon?.points) ? polygon.points : [];
          if (points.length < 2) {
            return null;
          }
          const coords = points.map((point) => ({
            x: parseNumeric(point.X, 0),
            y: parseNumeric(point.Y, 0),
          }));
          if (!coords.length) {
            return null;
          }
          const x = coords.map((point) => point.x);
          const y = coords.map((point) => point.y);
          const first = coords[0];
          const last = coords[coords.length - 1];
          if (first.x !== last.x || first.y !== last.y) {
            x.push(first.x);
            y.push(first.y);
          } else {
            x.push(first.x);
            y.push(first.y);
          }
          const truncatedLabel = formatLegendLabel(label);
          const polygonType = getPolygonTypeValue(polygon);
          const style = resolveShapeStyle(fieldType, polygonType);
          return {
            type: "scatter",
            mode: "lines",
            line: { color, width: style.lineWidth, dash: style.lineDash },
            fill: "toself",
            fillcolor: withAlpha(color, 0.12),
            name: truncatedLabel,
            meta: {
              fullLabel: label,
              kind: "polygon",
              fieldsetIndex,
              fieldIndex,
              shapeIndex: polygonIndex,
              shapeType: polygonType || "Field",
            },
            hovertemplate: "<b>%{meta.fullLabel}</b><extra></extra>",
            x,
            y,
          };
        }

function buildRectangleTrace(rectangle, color, label, fieldType, fieldsetIndex, fieldIndex, rectangleIndex) {
          const corners = getRectangleCornerPoints(rectangle);
          if (!corners || !corners.length) {
            return null;
          }
          const rotated = corners.concat(corners[0]);
          const truncatedLabel = formatLegendLabel(label);
          const style = resolveShapeStyle(fieldType, rectangle?.Type);
          return {
            type: "scatter",
            mode: "lines",
            line: { color, width: style.lineWidth, dash: style.lineDash },
            fill: "toself",
            fillcolor: withAlpha(color, 0.08),
            name: truncatedLabel,
            meta: {
              fullLabel: label,
              kind: "rectangle",
              fieldsetIndex,
              fieldIndex,
              shapeIndex: rectangleIndex,
              shapeType: rectangle?.Type || "Field",
            },
            hovertemplate: "<b>%{meta.fullLabel}</b><extra></extra>",
            x: rotated.map((point) => point.x),
            y: rotated.map((point) => point.y),
          };
        }

function buildCircleTrace(circle, color, label, fieldType, fieldsetIndex, fieldIndex, circleIndex) {
          if (!circle) {
            return null;
          }
          const radius = parseNumeric(circle.Radius, NaN);
          if (!Number.isFinite(radius) || radius <= 0) {
            return null;
          }
          const centerX = parseNumeric(circle.CenterX, 0);
          const centerY = parseNumeric(circle.CenterY, 0);
          const x = [];
          const y = [];
          for (let i = 0; i <= circleSampleSegments; i += 1) {
            const angle = (i / circleSampleSegments) * Math.PI * 2;
            x.push(centerX + radius * Math.cos(angle));
            y.push(centerY + radius * Math.sin(angle));
          }
          const truncatedLabel = formatLegendLabel(label);
          const style = resolveShapeStyle(fieldType, circle?.Type);
          return {
            type: "scatter",
            mode: "lines",
            line: { color, width: style.lineWidth, dash: style.lineDash },
            fill: "toself",
            fillcolor: withAlpha(color, 0.08),
            name: truncatedLabel,
            meta: {
              fullLabel: label,
              kind: "circle",
              fieldsetIndex,
              fieldIndex,
              shapeIndex: circleIndex,
              shapeType: circle?.Type || "Field",
            },
            hovertemplate: "<b>%{meta.fullLabel}</b><extra></extra>",
            x,
            y,
          };
        }

        function getRectangleCornerPoints(rectangle) {
          if (!rectangle) {
            return null;
          }
          const width = parseNumeric(rectangle.Width, NaN);
          const height = parseNumeric(rectangle.Height, NaN);
          if (!Number.isFinite(width) || !Number.isFinite(height) || width === 0 || height === 0) {
            return null;
          }
          const originX = parseNumeric(rectangle.OriginX, 0);
          const originY = parseNumeric(rectangle.OriginY, 0);
          const rotationDeg = parseNumeric(rectangle.Rotation, 0);
          const rotation = degreesToRadians(rotationDeg);
          const topLeft = { x: originX, y: originY };
          const topRight = { x: originX + width, y: originY };
          const bottomRight = { x: originX + width, y: originY - height };
          const bottomLeft = { x: originX, y: originY - height };
          const corners = [topLeft, topRight, bottomRight, bottomLeft];
          if (rotation === 0) {
            return corners;
          }
          return corners.map((corner) => rotateAroundCorner(corner, rotation, topLeft));
        }

        function rotatePoint(x, y, radians, originX, originY) {
          const cos = Math.cos(radians);
          const sin = Math.sin(radians);
          return {
            x: originX + x * cos - y * sin,
            y: originY + x * sin + y * cos,
          };
        }

        function rotateAroundCorner(point, radians, origin) {
          const translatedX = point.x - origin.x;
          const translatedY = point.y - origin.y;
          const rotated = rotatePoint(translatedX, translatedY, radians, 0, 0);
          return {
            x: rotated.x + origin.x,
            y: rotated.y + origin.y,
          };
        }

        function degreesToRadians(value) {
          return (Number(value) * Math.PI) / 180;
        }

        function normalizeDegrees(value) {
          const deg = Number(value);
          if (!Number.isFinite(deg)) {
            return 0;
          }
          const normalized = deg % 360;
          return normalized < 0 ? normalized + 360 : normalized;
        }

        function parseNumeric(value, fallback = NaN) {
          const num = Number.parseFloat(value);
          return Number.isFinite(num) ? num : fallback;
        }

        function withAlpha(color, alpha) {
          if (!color || typeof color !== "string") {
            return `rgba(15, 23, 42, ${alpha})`;
          }
          if (!color.startsWith("#")) {
            return color;
          }
          let hex = color.replace("#", "").trim();
          if (hex.length === 3) {
            hex = hex
              .split("")
              .map((ch) => ch + ch)
              .join("");
          }
          if (hex.length !== 6) {
            return color;
          }
          const r = parseInt(hex.slice(0, 2), 16);
          const g = parseInt(hex.slice(2, 4), 16);
          const b = parseInt(hex.slice(4, 6), 16);
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function calculateVisibleFieldsetRadius() {
          let maxDistance = 0;
          fieldsets.forEach((fieldset) => {
            if (fieldset.visible === false) {
              return;
            }
            (fieldset.fields || []).forEach((field) => {
              (field.polygons || []).forEach((polygon) => {
                (polygon.points || []).forEach((point) => {
                  const x = parseNumeric(point.X, 0);
                  const y = parseNumeric(point.Y, 0);
                  const dist = Math.hypot(x, y);
                  if (dist > maxDistance) {
                    maxDistance = dist;
                  }
                });
              });
              (field.rectangles || []).forEach((rectangle) => {
                const corners = getRectangleCornerPoints(rectangle) || [];
                corners.forEach((corner) => {
                  const dist = Math.hypot(corner.x, corner.y);
                  if (dist > maxDistance) {
                    maxDistance = dist;
                  }
                });
              });
              (field.circles || []).forEach((circle) => {
                const centerX = parseNumeric(circle.CenterX, 0);
                const centerY = parseNumeric(circle.CenterY, 0);
                const radius = Math.max(0, parseNumeric(circle.Radius, 0));
                const dist = Math.hypot(centerX, centerY) + radius;
                if (dist > maxDistance) {
                  maxDistance = dist;
                }
              });
            });
          });
          return maxDistance;
        }

        function calculateDeviceFanRadius() {
          const visibleRadius = calculateVisibleFieldsetRadius();
          if (!Number.isFinite(visibleRadius) || visibleRadius <= 0) {
            return 1000;
          }
          return visibleRadius + 500;
        }

        function buildDeviceOverlayTraces() {
          if (!Array.isArray(fieldsetDevices) || !fieldsetDevices.length) {
            return [];
          }
          const radius = calculateDeviceFanRadius();
          console.debug("Device overlay state", {
            deviceCount: fieldsetDevices.length,
            fieldOfViewDegrees,
            radius,
          });
          const traces = [];
          fieldsetDevices.forEach((device, deviceIndex) => {
            const attrs = device?.attributes || {};
            const x = parseNumeric(attrs.PositionX, NaN);
            const y = parseNumeric(attrs.PositionY, NaN);
            if (!Number.isFinite(x) || !Number.isFinite(y)) {
              return;
            }
            const deviceLabel =
              attrs.Typekey ||
              attrs.DeviceName ||
              `Device ${deviceIndex + 1}`;
            traces.push({
              type: "scatter",
              mode: "markers",
              marker: { color: "#111", size: 8 },
              name: formatLegendLabel(`${deviceLabel} position`),
              meta: { fullLabel: deviceLabel },
              hovertemplate:
                "<b>%{meta.fullLabel}</b><br>X: %{x}<br>Y: %{y}<extra></extra>",
              x: [x],
              y: [y],
              showlegend: false,
            });
            const rotation = parseNumeric(attrs.Rotation, 0);
            if (
              Number.isFinite(radius) &&
              radius > 0 &&
              Number.isFinite(fieldOfViewDegrees) &&
              fieldOfViewDegrees > 0
            ) {
              const fanTrace = buildDeviceFanTrace(
                x,
                y,
                rotation,
                radius,
                fieldOfViewDegrees,
                deviceLabel
              );
              if (fanTrace) {
                traces.push(fanTrace);
              }
            }
          });
          return traces;
        }

        function buildTriOrbShapeTraces() {
          if (!Array.isArray(triorbShapes) || !triorbShapes.length) {
            return [];
          }
          return triorbShapes
            .map((shape, shapeIndex) => {
              if (shape.visible === false) {
                return null;
              }
              const color = pickTriOrbColor(shapeIndex);
              const label = `${shape.name || `Shape ${shapeIndex + 1}`} (${shape.type})`;
              const fieldType = shape.fieldtype || "ProtectiveSafeBlanking";
              switch (shape.type) {
                case "Rectangle":
                  if (!shape.rectangle) return null;
                  return buildRectangleTrace(
                    shape.rectangle,
                    color,
                    label,
                    fieldType,
                    0,
                    0,
                    shapeIndex
                  );
                case "Circle":
                  if (!shape.circle) return null;
                  return buildCircleTrace(
                    shape.circle,
                    color,
                    label,
                    fieldType,
                    0,
                    0,
                    shapeIndex
                  );
                case "Polygon":
                default:
                  if (!shape.polygon) return null;
                  return buildPolygonTrace(
                    shape.polygon,
                    color,
                    label,
                    fieldType,
                    0,
                    0,
                    shapeIndex
                  );
              }
            })
            .filter(Boolean);
        }

        function buildDeviceFanTrace(originX, originY, rotationDeg, radius, fovDeg, label) {
          if (
            !Number.isFinite(radius) ||
            radius <= 0 ||
            !Number.isFinite(fovDeg) ||
            fovDeg <= 0
          ) {
            return null;
          }
          const adjustedRotation = normalizeDegrees(rotationDeg + 90);
          const halfFov = fovDeg / 2;
          const start = degreesToRadians(adjustedRotation - halfFov);
          const end = degreesToRadians(adjustedRotation + halfFov);
          const steps = Math.max(6, Math.floor(fovDeg / 6));
          const points = [];
          points.push({ x: originX, y: originY });
          points.push({
            x: originX + radius * Math.cos(start),
            y: originY + radius * Math.sin(start),
          });
          for (let i = 1; i <= steps; i += 1) {
            const angle = start + ((end - start) * i) / steps;
            points.push({
              x: originX + radius * Math.cos(angle),
              y: originY + radius * Math.sin(angle),
            });
          }
          points.push({
            x: originX,
            y: originY,
          });
          return {
            type: "scatter",
            mode: "lines",
            line: { color: "#111", width: 1.2, dash: "dot" },
            fill: "toself",
            fillcolor: "rgba(17, 17, 17, 0.08)",
            name: formatLegendLabel(`${label} FOV`),
            meta: { fullLabel: `${label} Field of View` },
            hovertemplate: "<b>%{meta.fullLabel}</b><extra></extra>",
            x: points.map((point) => point.x),
            y: points.map((point) => point.y),
            showlegend: false,
          };
        }

        function resolveShapeStyle(fieldType, shapeType) {
          const normalizedField = String(fieldType || "").toLowerCase();
          const normalizedShape = String(shapeType || "").toLowerCase();
          const isProtective = normalizedField.includes("protective");
          const isWarning = normalizedField.includes("warning");
          const protectiveOrWarning = isProtective || isWarning;

          const style = {
            lineWidth: 1.5,
            lineDash: "solid",
          };

          if (normalizedShape === "field") {
            if (isWarning) {
              style.lineWidth = 1;
              style.lineDash = "solid";
            } else if (isProtective) {
              style.lineWidth = 2;
              style.lineDash = "solid";
            }
          } else if (normalizedShape === "cutout" && protectiveOrWarning) {
            style.lineWidth = 2;
            style.lineDash = "dash";
          }

          return style;
        }

        function formatLegendLabel(label) {
          const text = String(label ?? "").trim();
          if (!text) {
            return "Trace";
          }
          if (text.length <= legendLabelMaxLength) {
            return text;
          }
          return `${text.slice(0, legendLabelMaxLength - 3)}...`;
        }

        function resetFigure() {
          currentFigure = cloneFigure(defaultFigure);
          renderFigure();
          setStatus("Default plot restored.");
        }

        function createDefaultScanPlane(index = scanPlanes.length) {
          return {
            attributes: {
              Index: String(index),
              Name: `Monitoring plane ${index + 1}`,
              ScanPlaneDirection: "Horizontal",
              UseReferenceContour: "false",
              ObjectSize: "70",
              MultipleSampling: "2",
              MultipleSamplingOff2OnActivated: "false",
              SelectedCaseSwitching: "Fast",
            },
            devices: createDefaultScanPlaneDevices(),
          };
        }

        function createDefaultDevice(index = 0, overrides = {}) {
          return {
            attributes: {
              Index: String(index),
              DeviceName: overrides.DeviceName || `Device ${index + 1}`,
              Typekey: overrides.Typekey || "NANS3-CAAZ30ZA1P02",
              TypekeyVersion: overrides.TypekeyVersion || "1.0",
              TypekeyDisplayVersion: overrides.TypekeyDisplayVersion || "V 1.0.0",
              ResponseTime: overrides.ResponseTime || "30",
              ScanResolutionAddition: overrides.ScanResolutionAddition || "0",
            },
          };
        }

        function createDefaultScanPlaneDevices() {
          if (!defaultScanDeviceTemplates.length) {
            return [createDefaultDevice(0)];
          }
          return defaultScanDeviceTemplates.map((template, index) =>
            createDefaultDevice(index, template)
          );
        }

        function renderScanPlanes() {
          if (!scanPlanesContainer) return;
          scanPlanesContainer.innerHTML = scanPlanes
            .map((plane, planeIndex) => {
              const planeFields = Object.entries(plane.attributes || {})
                .map(
                  ([key, value]) => `
              <div class="scanplane-field">
                <label>${escapeHtml(key)}</label>
                <input
                  type="text"
                  class="scanplane-attr"
                  data-plane-index="${planeIndex}"
                  data-field="${escapeHtml(key)}"
                  value="${escapeHtml(value ?? "")}"
                />
              </div>`
                )
                .join("");

              const deviceCards = (plane.devices || [])
                .map((device, deviceIndex) => {
                  const deviceFields = Object.entries(device.attributes || {})
                    .map(
                      ([key, value]) => `
                  <div class="device-field">
                    <label>${escapeHtml(key)}</label>
                    <input
                      type="text"
                      class="device-attr"
                      data-plane-index="${planeIndex}"
                      data-device-index="${deviceIndex}"
                      data-field="${escapeHtml(key)}"
                      value="${escapeHtml(value ?? "")}"
                    />
                  </div>`
                    )
                    .join("");

                  return `
                <div class="device-card" data-plane-index="${planeIndex}" data-device-index="${deviceIndex}">
                  <details class="device-details" open>
                    <summary>
                      <span>Device #${deviceIndex + 1}</span>
                      <span class="device-summary">${device.attributes.DeviceName || ""}</span>
                      <button
                        type="button"
                        class="inline-btn inline-danger"
                        data-action="remove-device"
                        data-plane-index="${planeIndex}"
                        data-device-index="${deviceIndex}"
                      >
                        Remove
                      </button>
                    </summary>
                    <div class="device-fields">${deviceFields}</div>
                  </details>
                </div>`;
                })
                .join("");

              return `
            <div class="scanplane-card" data-plane-index="${planeIndex}">
              <details class="scanplane-details" open>
                <summary>
                  <span>ScanPlane #${planeIndex + 1}</span>
                  <span class="scanplane-summary">${plane.attributes.Name || ""}</span>
                  <button
                    type="button"
                    class="inline-btn inline-danger"
                    data-action="remove-scanplane"
                    data-plane-index="${planeIndex}"
                  >
                    Remove
                  </button>
                </summary>
                <div class="scanplane-fields">${planeFields}</div>
                <div class="scanplane-devices">
                  ${deviceCards || "<p>No devices yet.</p>"}
                  <div class="scanplane-actions">
                    <button
                      type="button"
                      class="inline-btn add-device-btn"
                      data-action="add-device"
                      data-plane-index="${planeIndex}"
                    >
                      + Device
                    </button>
                  </div>
                </div>
              </details>
            </div>`;
            })
            .join("");
        }

        function ensureDefaultScanDevices(plane) {
          if (!plane) {
            return;
          }
          plane.devices = Array.isArray(plane.devices) ? plane.devices : [];
          const existingNames = new Set(
            plane.devices
              .map((device) => (device.attributes?.DeviceName || "").toLowerCase())
              .filter(Boolean)
          );
          defaultScanDeviceTemplates.forEach((template) => {
            const templateName = (template.DeviceName || "").toLowerCase();
            if (templateName && !existingNames.has(templateName)) {
              const newDevice = createDefaultDevice(plane.devices.length, template);
              plane.devices.push(newDevice);
              existingNames.add(templateName);
            }
          });
        }

        function updateScanPlaneAttribute(planeIndex, field, value) {
          if (scanPlanes[planeIndex]) {
            scanPlanes[planeIndex].attributes[field] = value;
            if (field === "Name") {
              const summary = document.querySelector(
                `.scanplane-card[data-plane-index="${planeIndex}"] .scanplane-summary`
              );
              if (summary) {
                summary.textContent = value;
              }
            }
          }
        }

        function updateDeviceAttribute(planeIndex, deviceIndex, field, value) {
          const plane = scanPlanes[planeIndex];
          if (plane && plane.devices && plane.devices[deviceIndex]) {
            plane.devices[deviceIndex].attributes[field] = value;
            if (field === "DeviceName") {
              const deviceSummary = document.querySelector(
                `.device-card[data-plane-index="${planeIndex}"][data-device-index="${deviceIndex}"] .device-summary`
              );
              if (deviceSummary) {
                deviceSummary.textContent = value;
              }
            }
          }
        }

        function getScanPlaneDeviceOptions() {
          const options = [];
          const seen = new Set();
          scanPlanes.forEach((plane) => {
            (plane.devices || []).forEach((device, index) => {
              const attrs = device.attributes || {};
              const name = (attrs.DeviceName || attrs.Typekey || `Device ${index + 1}`).trim();
              if (!name) {
                return;
              }
              const key = name.toLowerCase();
              if (seen.has(key)) {
                return;
              }
              seen.add(key);
              options.push({
                deviceName: name,
                typekey: attrs.Typekey || "",
                typekeyDisplayVersion: attrs.TypekeyDisplayVersion || "",
                typekeyVersion: attrs.TypekeyVersion || "",
                label: attrs.Typekey ? `${name} (${attrs.Typekey})` : name,
              });
            });
          });
          return options;
        }

        function findScanPlaneDeviceByTypekey(typekey) {
          if (!typekey) {
            return null;
          }
          for (const plane of scanPlanes) {
            for (const device of plane.devices || []) {
              if ((device.attributes || {}).Typekey === typekey) {
                return device;
              }
            }
          }
          return null;
        }

        function findScanPlaneDeviceByName(name) {
          if (!name) {
            return null;
          }
          const normalized = name.trim().toLowerCase();
          for (const plane of scanPlanes) {
            for (const device of plane.devices || []) {
              const deviceName = (device.attributes || {}).DeviceName || "";
              if (deviceName.trim().toLowerCase() === normalized) {
                return device;
              }
            }
          }
          return null;
        }

        function applyScanPlaneDeviceAttributes(targetDevice, { deviceName, typekey } = {}) {
          targetDevice.attributes = targetDevice.attributes || {};
          if (deviceName) {
            targetDevice.attributes.DeviceName = deviceName;
          }
          let source =
            (deviceName && findScanPlaneDeviceByName(deviceName)) ||
            (typekey && findScanPlaneDeviceByTypekey(typekey)) ||
            null;
          if (!source) {
            return;
          }
          const attrs = source.attributes || {};
          targetDevice.attributes.Typekey = attrs.Typekey || typekey || targetDevice.attributes.Typekey || "";
          targetDevice.attributes.TypekeyDisplayVersion =
            attrs.TypekeyDisplayVersion || targetDevice.attributes.TypekeyDisplayVersion || "";
          targetDevice.attributes.TypekeyVersion =
            attrs.TypekeyVersion || targetDevice.attributes.TypekeyVersion || "";
        }

        function findTriOrbShapeById(shapeId) {
          return triorbShapes.find((shape) => shape.id === shapeId) || null;
        }

        function normalizeFieldShapeRefs(field) {
          if (!field) {
            return [];
          }
          if (Array.isArray(field.shapeRefs) && field.shapeRefs.length) {
            return field.shapeRefs
              .map((ref) => (ref && ref.shapeId ? { shapeId: ref.shapeId } : null))
              .filter(Boolean);
          }
          return [];
        }

        function initializeFieldsets(data) {
          if (!Array.isArray(data) || !data.length) {
            return [createDefaultFieldset(0)];
          }
          return data.map((fieldset, index) => ({
            attributes: {
              Name: fieldset.attributes?.Name || `Fieldset ${index + 1}`,
              ...fieldset.attributes,
            },
            fields:
              Array.isArray(fieldset.fields) && fieldset.fields.length
                ? fieldset.fields.map((field, fieldIndex) => ({
                    attributes: {
                      Name: field.attributes?.Name || `Field ${fieldIndex + 1}`,
                      ...field.attributes,
                    },
                    shapeRefs: normalizeFieldShapeRefs(field),
                  }))
                : [createDefaultField(0)],
            visible: fieldset.visible !== false,
          }));
        }

        function createDefaultFieldset(index = fieldsets.length) {
          const isFirst = index === 0;
          return {
            attributes: {
              Name: isFirst ? "Default" : `Fieldset ${index + 1}`,
              NameLatin9Key: `FS_DEFAULT_${index + 1}`,
            },
            fields: [createDefaultField(0)],
            visible: true,
          };
        }

        function createDefaultField(index = 0) {
          const samplingValue =
            typeof globalMultipleSampling === "undefined"
              ? "2"
              : globalMultipleSampling;
          const newShape = createDefaultTriOrbShape(triorbShapes.length, "Polygon");
          triorbShapes.push(newShape);
          return {
            attributes: {
              Name: `Field ${index + 1}`,
              Fieldtype: "ProtectiveSafeBlanking",
              MultipleSampling: samplingValue,
              Resolution: "70",
              TolerancePositive: "0",
              ToleranceNegative: "0",
            },
            shapeRefs: [{ shapeId: newShape.id }],
          };
        }

        function deriveInitialMultipleSampling(fieldsetList) {
          for (const fieldset of fieldsetList) {
            if (!fieldset.fields) continue;
            for (const field of fieldset.fields) {
              if (field.attributes?.MultipleSampling) {
                return field.attributes.MultipleSampling;
              }
            }
          }
          return "2";
        }

        function deriveFieldAttribute(fieldsetList, key, fallback) {
          for (const fieldset of fieldsetList) {
            if (!fieldset.fields) continue;
            for (const field of fieldset.fields) {
              if (field.attributes && key in field.attributes) {
                return parseNumeric(field.attributes[key], fallback);
              }
            }
          }
          return fallback;
        }

        function applyGlobalMultipleSampling(value, { rerender = true } = {}) {
          globalMultipleSampling = value;
          if (globalMultipleSamplingInput) {
            globalMultipleSamplingInput.value = value;
          }
          updateGlobalFieldAttributes();
          if (rerender) {
            renderFieldsets();
          }
        }

        function createDefaultPolygon() {
          return {
            attributes: { Type: "CutOut" },
            points: [
              { X: "0", Y: "0" },
              { X: "100", Y: "0" },
              { X: "100", Y: "100" },
              { X: "0", Y: "100" },
            ],
          };
        }

        function createDefaultRectangle() {
          return {
            Type: "Field",
            OriginX: "0",
            OriginY: "0",
            Height: "100",
            Width: "100",
            Rotation: "0",
          };
        }

        function createDefaultCircle() {
          return {
            Type: "Field",
            CenterX: "0",
            CenterY: "0",
            Radius: "100",
          };
        }

        function formatFieldsetAttribute(fieldsetIndex, key, value) {
          return `
              <div class="fieldset-field">
                <label>${escapeHtml(key)}</label>
                <input
                  type="text"
                  class="fieldset-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field="${escapeHtml(key)}"
                  value="${escapeHtml(value ?? "")}"
                />
              </div>`;
        }

        function formatFieldAttribute(fieldsetIndex, fieldIndex, key, value) {
          const hidden =
            ["MultipleSampling", "Resolution", "TolerancePositive", "ToleranceNegative"].includes(
              key
            ) && !debugMode;
          if (hidden) return "";
          const hiddenClass = hidden ? "field-attribute debug-hidden" : "field-attribute";
          if (key === "Fieldtype") {
            const options = ["ProtectiveSafeBlanking", "WarningSafeBlanking"]
              .map(
                (opt) =>
                  `<option value="${opt}"${opt === value ? " selected" : ""}>${opt}</option>`
              )
              .join("");
            return `
              <div class="${hiddenClass}">
                <label>${escapeHtml(key)}</label>
                <select
                  class="field-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-field="${escapeHtml(key)}"
                >
                  ${options}
                </select>
              </div>`;
          }
          if (key === "MultipleSampling") {
            return `
              <div class="${hiddenClass}">
                <label>${escapeHtml(key)}</label>
                <input type="number" value="${escapeHtml(globalMultipleSampling)}" min="2" max="16" readonly />
              </div>`;
          }
          if (key === "Resolution") {
            return `
              <div class="${hiddenClass}">
                <label>${escapeHtml(key)}</label>
                <input type="number" value="${escapeHtml(String(globalResolution))}" readonly />
              </div>`;
          }
          if (key === "TolerancePositive" || key === "ToleranceNegative") {
            const bound = key === "TolerancePositive" ? globalTolerancePositive : globalToleranceNegative;
            return `
              <div class="${hiddenClass}">
                <label>${escapeHtml(key)}</label>
                <input type="number" value="${escapeHtml(String(bound))}" readonly />
              </div>`;
          }
          return `
              <div class="field-attribute">
                <label>${escapeHtml(key)}</label>
                <input
                  type="text"
                  class="field-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-field="${escapeHtml(key)}"
                  value="${escapeHtml(value ?? "")}"
                />
              </div>`;
        }

        function renderFieldsets() {
          if (!fieldsetsContainer) {
            return;
          }
          const detailState = captureFieldsetDetailState();
          if (!fieldsets.length) {
            fieldsetsContainer.innerHTML = "<p>No fieldsets defined.</p>";
            return;
          }
          fieldsetsContainer.innerHTML = fieldsets
            .map((fieldset, fieldsetIndex) => {
              const fieldsetFields = Object.entries(fieldset.attributes || {})
                .map(([key, value]) => formatFieldsetAttribute(fieldsetIndex, key, value))
                .join("");

              const fieldCards = (fieldset.fields || [])
                .map((field, fieldIndex) => {
                  const fieldAttrs = Object.entries(field.attributes || {})
                    .map(([key, value]) => {
                      if (key === "Fieldtype") {
                        const options = [
                          "ProtectiveSafeBlanking",
                          "WarningSafeBlanking",
                        ]
                          .map(
                            (opt) =>
                              `<option value="${opt}"${
                                opt === value ? " selected" : ""
                              }>${opt}</option>`
                          )
                          .join("");
                        return `
              <div class="field-attribute">
                <label>${escapeHtml(key)}</label>
                <select
                  class="field-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-field="${escapeHtml(key)}"
                >
                  ${options}
                </select>
              </div>`;
                      }
                      if (key === "MultipleSampling") {
                        return `
              <div class="field-attribute">
                <label>${escapeHtml(key)}</label>
                <input
                  type="number"
                  value="${escapeHtml(globalMultipleSampling)}"
                  min="2"
                  max="16"
                  readonly
                />
              </div>`;
                      }
                      return formatFieldAttribute(fieldsetIndex, fieldIndex, key, value);
                    })
                    .join("");

                  const shapeRefs = Array.isArray(field.shapeRefs) ? field.shapeRefs : [];
                  const shapeItems =
                    shapeRefs
                      .map((shapeRef, shapeIndex) => {
                        const shape = findTriOrbShapeById(shapeRef.shapeId);
                        if (!shape) {
                          return `
                            <div class="field-shape-entry missing">
                              <span>Shape removed</span>
                            </div>`;
                        }
                        return `
                          <div
                            class="field-shape-entry"
                            data-shape-index="${shapeIndex}"
                          >
                            <div class="shape-info">
                              <span class="shape-name">${escapeHtml(
                                shape.name || shape.id
                              )}</span>
                              <span class="shape-type">${escapeHtml(shape.type)}</span>
                            </div>
                            <div class="shape-actions">
                              <button
                                type="button"
                                class="inline-btn shape-mini-btn"
                                data-action="edit-field-shape"
                                data-shape-id="${escapeHtml(shape.id)}"
                              >
                                Edit
                              </button>
                              <button
                                type="button"
                                class="inline-btn inline-danger shape-mini-btn"
                                data-action="remove-field-shape"
                                data-fieldset-index="${fieldsetIndex}"
                                data-field-index="${fieldIndex}"
                                data-shape-index="${shapeIndex}"
                              >
                                Remove
                              </button>
                            </div>
                          </div>`;
                      })
                      .join("") || "<p>No shapes assigned.</p>";
                  const shapeControls = renderFieldShapeControls(
                    fieldsetIndex,
                    fieldIndex,
                    field
                  );

                  return `
            <div
              class="field-card"
              data-fieldset-index="${fieldsetIndex}"
              data-field-index="${fieldIndex}"
            >
              <details class="field-details" open>
                <summary>
                  <span>Field #${fieldIndex + 1}</span>
                  <span class="field-summary">${field.attributes.Name || ""}</span>
                  <button
                    type="button"
                    class="inline-btn inline-danger"
                    data-action="remove-field"
                    data-fieldset-index="${fieldsetIndex}"
                    data-field-index="${fieldIndex}"
                  >
                    Remove
                  </button>
                </summary>
                <div class="field-attributes">${fieldAttrs}</div>
                <div class="shape-section">
                  <h4>Assigned Shapes</h4>
                  <div class="shape-list">${shapeItems}</div>
                  ${shapeControls}
                </div>
              </details>
            </div>`;
                })
                .join("") || "<p>No fields defined.</p>";

              return `
          <div class="fieldset-card" data-fieldset-index="${fieldsetIndex}">
            <details class="fieldset-details">
              <summary>
                <span>Fieldset #${fieldsetIndex + 1}</span>
                <span class="fieldset-summary">${fieldset.attributes.Name || ""}</span>
                <button
                  type="button"
                  class="inline-btn inline-danger"
                  data-action="remove-fieldset"
                  data-fieldset-index="${fieldsetIndex}"
                >
                  Remove
                </button>
              </summary>
              <div class="fieldset-fields">${fieldsetFields}</div>
              <div class="field-card-list">
                ${fieldCards}
                <div class="field-actions">
                  <button
                    type="button"
                    class="inline-btn"
                    data-action="add-field"
                    data-fieldset-index="${fieldsetIndex}"
                  >
                    + Field
                  </button>
                </div>
              </div>
            </details>
          </div>`;
            })
            .join("");
          renderFieldsetCheckboxes();
          renderFigure();
          restoreFieldsetDetailState(detailState);
        }

        function renderFieldShapeControls(fieldsetIndex, fieldIndex, field) {
          const currentIds = new Set((field.shapeRefs || []).map((ref) => ref.shapeId));
          const availableShapes = triorbShapes.filter((shape) => !currentIds.has(shape.id));
          if (!availableShapes.length) {
            return `<p class="shape-controls-note">No additional shapes to add.</p>`;
          }
          const options = availableShapes
            .map(
              (shape) =>
                `<option value="${escapeHtml(shape.id)}">${escapeHtml(
                  shape.name || shape.id
                )} (${escapeHtml(shape.type)})</option>`
            )
            .join("");
          return `
            <div class="shape-controls">
              <select
                class="field-shape-selector"
                data-fieldset-index="${fieldsetIndex}"
                data-field-index="${fieldIndex}"
              >
                ${options}
              </select>
              <button
                type="button"
                class="inline-btn"
                data-action="add-field-shape"
                data-fieldset-index="${fieldsetIndex}"
                data-field-index="${fieldIndex}"
              >
                Add Shape
              </button>
            </div>`;
        }

        function initializeTriOrbShapes(data) {
          if (!Array.isArray(data) || !data.length) {
            return [createDefaultTriOrbShape(0)];
          }
          return data.map((shape, index) => {
            const fieldtype = shape.fieldtype || "ProtectiveSafeBlanking";
            const inferredKind =
              shape.kind ||
              shape.Kind ||
              getPolygonTypeValue(shape.polygon) ||
              (shape.rectangle && shape.rectangle.Type) ||
              (shape.circle && shape.circle.Type) ||
              "Field";
            const polygon = shape.polygon
              ? JSON.parse(JSON.stringify(shape.polygon))
              : createDefaultPolygonDetails();
            if (!getPolygonTypeValue(polygon)) {
              setPolygonTypeValue(polygon, inferredKind);
            }
            const rectangle = shape.rectangle
              ? JSON.parse(JSON.stringify(shape.rectangle))
              : createDefaultRectangleDetails();
            rectangle.Type = rectangle.Type || inferredKind;
            const circle = shape.circle
              ? JSON.parse(JSON.stringify(shape.circle))
              : createDefaultCircleDetails();
            circle.Type = circle.Type || inferredKind;
            const normalizedShape = {
              id: shape.id || createShapeId(),
              name: shape.name || `Shape ${index + 1}`,
              type: shape.type || "Polygon",
              fieldtype,
              kind: inferredKind,
              polygon,
              rectangle,
              circle,
              visible: shape.visible !== false,
            };
            applyShapeKind(normalizedShape, inferredKind);
            return normalizedShape;
          });
        }

        function createDefaultTriOrbShape(index, geometryType = "Polygon") {
          const polygon = createDefaultPolygonDetails();
          const rectangle = createDefaultRectangleDetails();
          const circle = createDefaultCircleDetails();
          const shape = {
            id: createShapeId(),
            name: `Shape ${index + 1}`,
            type: geometryType,
            fieldtype: "ProtectiveSafeBlanking",
            kind: "Field",
            polygon,
            rectangle,
            circle,
            visible: true,
          };
          applyShapeKind(shape, shape.kind);
          return shape;
        }

        function createShapeId() {
          return `shape-${Math.random().toString(36).slice(2, 10)}`;
        }

        function createDefaultPolygonDetails() {
          return {
            Type: "CutOut",
            points: [
              { X: "0", Y: "0" },
              { X: "100", Y: "0" },
              { X: "100", Y: "100" },
              { X: "0", Y: "100" },
            ],
          };
        }

        function formatPolygonPoints(points) {
          return (points || [])
            .map((point) => `(${point.X},${point.Y})`)
            .join(",");
        }

        function parsePolygonPoints(value) {
          const sanitized = (value || "").trim();
          if (!sanitized) {
            return [];
          }
          return sanitized
            .split("),")
            .map((segment) => segment.replace(/[()]/g, "").trim())
            .filter(Boolean)
            .map((pair) => {
              const [x, y] = pair.split(",").map((v) => v.trim());
              return { X: x || "0", Y: y || "0" };
            });
        }

        function createDefaultRectangleDetails() {
          return {
            Type: "Field",
            OriginX: "0",
            OriginY: "0",
            Width: "100",
            Height: "100",
            Rotation: "0",
          };
        }

        function createDefaultCircleDetails() {
          return {
            Type: "Field",
            CenterX: "0",
            CenterY: "0",
            Radius: "100",
          };
        }

        function getPolygonTypeValue(polygon) {
          if (!polygon) {
            return undefined;
          }
          if (polygon.attributes && typeof polygon.attributes.Type !== "undefined") {
            return polygon.attributes.Type;
          }
          return polygon.Type;
        }

        function setPolygonTypeValue(polygon, value) {
          if (!polygon || typeof value === "undefined") {
            return;
          }
          if (polygon.attributes) {
            polygon.attributes.Type = value;
          } else {
            polygon.Type = value;
          }
        }

        function applyShapeKind(shape, kind) {
          if (!shape) {
            return;
          }
          const normalized = kind || "Field";
          shape.kind = normalized;
          setPolygonTypeValue(shape.polygon, normalized);
          if (shape.rectangle) {
            shape.rectangle.Type = normalized;
          }
          if (shape.circle) {
            shape.circle.Type = normalized;
          }
        }

        function renderTriOrbShapes() {
          if (!triorbShapesContainer) {
            return;
          }
          if (!triorbShapes.length) {
            triorbShapesContainer.innerHTML = "<p>No shapes defined.</p>";
            return;
          }
          triorbShapesContainer.innerHTML = triorbShapes
            .map((shape, shapeIndex) => renderTriOrbShapeCard(shapeIndex, shape))
            .join("");
        }

        function renderTriOrbShapeCard(shapeIndex, shape) {
          const details = renderTriOrbShapeDetails(shape, shapeIndex);
          const geometrySelect = ["Polygon", "Rectangle", "Circle"]
            .map(
              (type) =>
                `<option value="${type}"${
                  type === shape.type ? " selected" : ""
                }>${type}</option>`
            )
            .join("");
          const fieldtypeSelect = ["ProtectiveSafeBlanking", "WarningSafeBlanking"]
            .map(
              (opt) =>
                `<option value="${opt}"${
                  opt === shape.fieldtype ? " selected" : ""
                }>${opt}</option>`
            )
            .join("");
          const kindSelect = ["Field", "CutOut"]
            .map(
              (opt) =>
                `<option value="${opt}"${
                  opt === shape.kind ? " selected" : ""
                }>${opt}</option>`
            )
            .join("");
          return `
            <div class="triorb-shape-card" data-shape-index="${shapeIndex}">
          <div class="shape-row">
            <span>ID: ${escapeHtml(shape.id)}</span>
            <label>
              Name
              <input
                type="text"
                class="triorb-shape-name"
                data-shape-index="${shapeIndex}"
                data-field="name"
                value="${escapeHtml(shape.name)}"
              />
            </label>
            <label>
              Fieldtype
              <select
                class="triorb-shape-fieldtype"
                data-shape-index="${shapeIndex}"
                data-field="fieldtype"
              >
                ${fieldtypeSelect}
              </select>
            </label>
            <label>
              Type
              <select
                class="triorb-shape-kind"
                data-shape-index="${shapeIndex}"
                data-field="kind"
              >
                ${kindSelect}
              </select>
            </label>
            <label>
              Geometry
              <select
                class="triorb-shape-type"
                data-shape-index="${shapeIndex}"
                data-field="type"
              >
                ${geometrySelect}
              </select>
            </label>
            <button
              type="button"
              class="inline-btn inline-danger shape-mini-btn"
              data-action="remove-triorb-shape"
              data-shape-index="${shapeIndex}"
            >
              Remove
            </button>
          </div>
              <div class="shape-details">${details}</div>
            </div>`;
        }

        function renderTriOrbShapeDetails(shape, shapeIndex) {
          switch (shape.type) {
            case "Rectangle":
              return ["OriginX", "OriginY", "Width", "Height", "Rotation"]
                .map((key) => {
                  const value = shape.rectangle?.[key] ?? "0";
                  return `
                    <label>
                      ${key}
                      <input
                        type="number"
                        data-shape-index="${shapeIndex}"
                        data-field="${key}"
                        data-shape-dimension="rectangle"
                        value="${escapeHtml(value)}"
                      />
                    </label>`;
                })
                .join("");
            case "Circle":
              return ["CenterX", "CenterY", "Radius"]
                .map((key) => {
                  const value = shape.circle?.[key] ?? "0";
                  return `
                    <label>
                      ${key}
                      <input
                        type="number"
                        data-shape-index="${shapeIndex}"
                        data-field="${key}"
                        data-shape-dimension="circle"
                        value="${escapeHtml(value)}"
                      />
                    </label>`;
                })
                .join("");
            case "Polygon":
            default:
              return `
                <label>
                  Points (format: (x1,y1),(x2,y2),...)
                  <input
                    type="text"
                    data-shape-index="${shapeIndex}"
                    data-shape-dimension="polygon"
                    value="${escapeHtml(formatPolygonPoints(shape.polygon?.points || []))}"
                  />
                </label>`;
          }
        }

        function handleTriOrbShapeInput(event) {
          const target = event.target;
          if (!target) return;
          const shapeIndex = Number(target.dataset.shapeIndex);
          if (!Number.isFinite(shapeIndex)) {
            return;
          }
          const shape = triorbShapes[shapeIndex];
          if (!shape) return;
          const field = target.dataset.field;
          const dimension = target.dataset["shapeDimension"];
          let changed = false;
          if (field === "name") {
            shape.name = target.value;
            changed = true;
          } else if (field === "fieldtype") {
            shape.fieldtype = target.value;
            changed = true;
          } else if (field === "kind") {
            applyShapeKind(shape, target.value);
            changed = true;
          } else if (field === "type") {
            shape.type = target.value;
            if (shape.type === "Polygon") {
              shape.polygon = shape.polygon || createDefaultPolygonDetails();
            } else if (shape.type === "Rectangle") {
              shape.rectangle = shape.rectangle || createDefaultRectangleDetails();
            } else if (shape.type === "Circle") {
              shape.circle = shape.circle || createDefaultCircleDetails();
            }
            renderTriOrbShapes();
            renderTriOrbShapeCheckboxes();
            applyShapeKind(shape, shape.kind || "Field");
            changed = true;
          } else if (dimension === "polygon") {
            if (!shape.polygon) {
              shape.polygon = createDefaultPolygonDetails();
            }
            shape.polygon.points = parsePolygonPoints(target.value);
            changed = true;
          } else if (dimension === "rectangle") {
            shape.rectangle = shape.rectangle || createDefaultRectangleDetails();
            shape.rectangle[field] = target.value;
            changed = true;
          } else if (dimension === "circle") {
            shape.circle = shape.circle || createDefaultCircleDetails();
            shape.circle[field] = target.value;
            changed = true;
          }
          if (changed) {
            renderFigure();
            renderFieldsets();
          }
        }

        function renderPolygonEditor(fieldsetIndex, fieldIndex, polygon, polygonIndex) {
          const typeSelect = renderShapeTypeSelect(
            "polygon",
            polygon.attributes?.Type || "CutOut",
            "polygon-type",
            {
              "fieldset-index": fieldsetIndex,
              "field-index": fieldIndex,
              "polygon-index": polygonIndex,
            }
          );
          const pointInputs = (polygon.points || [])
            .map(
              (point, pointIndex) => `
              <div class="shape-point" data-point-index="${pointIndex}">
                <label>X</label>
                <input
                  type="number"
                  class="polygon-point"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                  data-point-index="${pointIndex}"
                  data-axis="X"
                  value="${escapeHtml(point.X ?? "0")}"
                />
                <label>Y</label>
                <input
                  type="number"
                  class="polygon-point"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                  data-point-index="${pointIndex}"
                  data-axis="Y"
                  value="${escapeHtml(point.Y ?? "0")}"
                />
                <button
                  type="button"
                  class="inline-btn inline-danger shape-mini-btn"
                  data-action="remove-polygon-point"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                  data-point-index="${pointIndex}"
                >
                  Remove
                </button>
              </div>`
            )
            .join("");
          return `
            <div class="shape-entry" data-shape="polygon">
              <div class="shape-title">
                <span>Polygon #${polygonIndex + 1}</span>
                <button
                  type="button"
                  class="inline-btn inline-danger shape-mini-btn"
                  data-action="remove-polygon"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                >
                  Remove
                </button>
              </div>
              <div class="shape-fields">
                <label>Type</label>
                ${typeSelect}
              </div>
              <div class="shape-points">
                ${pointInputs || "<p>No points.</p>"}
              </div>
              <div class="shape-actions">
                <button
                  type="button"
                  class="inline-btn shape-mini-btn"
                  data-action="add-polygon-point"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                >
                  Add Point
                </button>
              </div>
            </div>`;
        }

        function renderRectangleEditor(fieldsetIndex, fieldIndex, rectangle, rectangleIndex) {
          const typeSelect = renderShapeTypeSelect(
            "rectangle",
            rectangle.Type || "Field",
            "rectangle-type",
            {
              "fieldset-index": fieldsetIndex,
              "field-index": fieldIndex,
              "rectangle-index": rectangleIndex,
            }
          );
          const fields = ["OriginX", "OriginY", "Width", "Height", "Rotation"].map(
            (key) => `
              <div class="shape-field">
                <label>${key}</label>
                <input
                  type="number"
                  class="rectangle-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-rectangle-index="${rectangleIndex}"
                  data-field="${key}"
                  value="${escapeHtml(rectangle[key] ?? "0")}"
                />
              </div>`
          );
          return `
            <div class="shape-entry" data-shape="rectangle">
              <div class="shape-title">
                <span>Rectangle #${rectangleIndex + 1}</span>
                <button
                  type="button"
                  class="inline-btn inline-danger shape-mini-btn"
                  data-action="remove-rectangle"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-rectangle-index="${rectangleIndex}"
                >
                  Remove
                </button>
              </div>
              <div class="shape-fields">
                <label>Type</label>
                ${typeSelect}
              </div>
              <div class="shape-grid">
                ${fields.join("")}
              </div>
            </div>`;
        }

        function renderCircleEditor(fieldsetIndex, fieldIndex, circle, circleIndex) {
          const typeSelect = renderShapeTypeSelect(
            "circle",
            circle.Type || "Field",
            "circle-type",
            {
              "fieldset-index": fieldsetIndex,
              "field-index": fieldIndex,
              "circle-index": circleIndex,
            }
          );
          const circleFields = ["CenterX", "CenterY", "Radius"].map(
            (key) => `
              <div class="shape-field">
                <label>${key}</label>
                <input
                  type="number"
                  class="circle-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-circle-index="${circleIndex}"
                  data-field="${key}"
                  value="${escapeHtml(circle[key] ?? "0")}"
                />
              </div>`
          );
          return `
            <div class="shape-entry" data-shape="circle">
              <div class="shape-title">
                <span>Circle #${circleIndex + 1}</span>
                <button
                  type="button"
                  class="inline-btn inline-danger shape-mini-btn"
                  data-action="remove-circle"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-circle-index="${circleIndex}"
                >
                  Remove
                </button>
              </div>
              <div class="shape-fields">
                <label>Type</label>
                ${typeSelect}
              </div>
              <div class="shape-grid">
                ${circleFields.join("")}
              </div>
            </div>`;
        }

        function renderShapeTypeSelect(kind, currentValue, className, dataAttrs) {
          const options = new Set(shapeTypeOptions[kind] || []);
          if (currentValue) {
            options.add(currentValue);
          }
          const dataAttrString = Object.entries(dataAttrs || {})
            .map(([key, value]) => ` data-${key}="${escapeHtml(String(value))}"`)
            .join("");
          return `
            <select class="${className}"${dataAttrString}>
              ${Array.from(options)
                .map(
                  (option) =>
                    `<option value="${escapeHtml(option)}"${
                      option === currentValue ? " selected" : ""
                    }>${escapeHtml(option)}</option>`
                )
                .join("")}
            </select>`;
        }

        function updateFieldAttribute(fieldsetIndex, fieldIndex, key, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          if (!field) return;
          field.attributes[key] = value;
          if (key === "Name") {
            const summary = document.querySelector(
              `.field-card[data-fieldset-index="${fieldsetIndex}"][data-field-index="${fieldIndex}"] .field-summary`
            );
            if (summary) {
              summary.textContent = value;
            }
          }
          renderFigure();
        }

        function updatePolygonAttribute(fieldsetIndex, fieldIndex, polygonIndex, key, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          const polygon = field?.polygons?.[polygonIndex];
          if (!polygon) return;
          polygon.attributes = polygon.attributes || {};
          polygon.attributes[key] = value;
          renderFieldsets();
          renderFigure();
        }

        function updatePolygonPoint(fieldsetIndex, fieldIndex, polygonIndex, pointIndex, axis, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          const polygon = field?.polygons?.[polygonIndex];
          if (!polygon || !polygon.points || !polygon.points[pointIndex]) {
            return;
          }
          polygon.points[pointIndex][axis] = value;
          renderFieldsets();
          renderFigure();
        }

        function updateRectangleAttribute(fieldsetIndex, fieldIndex, rectangleIndex, key, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          const rectangle = field?.rectangles?.[rectangleIndex];
          if (!rectangle) return;
          rectangle[key] = value;
          renderFieldsets();
          renderFigure();
        }

        function updateCircleAttribute(fieldsetIndex, fieldIndex, circleIndex, key, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          const circle = field?.circles?.[circleIndex];
          if (!circle) return;
          circle[key] = value;
          renderFieldsets();
          renderFigure();
        }

        function captureFieldsetDetailState() {
          if (!fieldsetsContainer) {
            return { fieldsets: new Set(), fields: new Set() };
          }
          const state = { fieldsets: new Set(), fields: new Set() };
          fieldsetsContainer.querySelectorAll(".fieldset-card").forEach((card) => {
            const fieldsetIndex = card.dataset.fieldsetIndex;
            const details = card.querySelector("details");
            if (details?.open && fieldsetIndex !== undefined) {
              state.fieldsets.add(fieldsetIndex);
            }
            card.querySelectorAll(".field-card").forEach((fieldCard) => {
              const fieldIndex = fieldCard.dataset.fieldIndex;
              const fieldDetails = fieldCard.querySelector("details");
              if (
                fieldDetails?.open &&
                fieldsetIndex !== undefined &&
                fieldIndex !== undefined
              ) {
                state.fields.add(`${fieldsetIndex}:${fieldIndex}`);
              }
            });
          });
          return state;
        }

        function restoreFieldsetDetailState(state) {
          if (!state || !fieldsetsContainer) {
            return;
          }
          fieldsetsContainer.querySelectorAll(".fieldset-card").forEach((card) => {
            const fieldsetIndex = card.dataset.fieldsetIndex;
            if (state.fieldsets.has(fieldsetIndex)) {
              const details = card.querySelector("details");
              if (details) {
                details.open = true;
              }
            }
            card.querySelectorAll(".field-card").forEach((fieldCard) => {
              const fieldIndex = fieldCard.dataset.fieldIndex;
              const key = `${fieldsetIndex}:${fieldIndex}`;
              if (state.fields.has(key)) {
                const details = fieldCard.querySelector("details");
                if (details) {
                  details.open = true;
                }
              }
            });
          });
        }

        function getFieldEntry(fieldsetIndex, fieldIndex) {
          const fieldset = fieldsets[fieldsetIndex];
          if (!fieldset || !fieldset.fields) {
            return null;
          }
          return fieldset.fields[fieldIndex] || null;
        }

        function addPolygon(fieldsetIndex, fieldIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field) return;
          field.polygons = field.polygons || [];
          field.polygons.push(createDefaultPolygon());
          renderFieldsets();
        }

        function removePolygon(fieldsetIndex, fieldIndex, polygonIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field || !field.polygons) return;
          field.polygons.splice(polygonIndex, 1);
          renderFieldsets();
        }

        function addPolygonPoint(fieldsetIndex, fieldIndex, polygonIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          const polygon = field?.polygons?.[polygonIndex];
          if (!polygon) return;
          polygon.points = polygon.points || [];
          polygon.points.push({ X: "0", Y: "0" });
          renderFieldsets();
        }

        function removePolygonPoint(fieldsetIndex, fieldIndex, polygonIndex, pointIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          const polygon = field?.polygons?.[polygonIndex];
          if (!polygon || !polygon.points) return;
          polygon.points.splice(pointIndex, 1);
          renderFieldsets();
        }

        function addCircle(fieldsetIndex, fieldIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field) return;
          field.circles = field.circles || [];
          field.circles.push(createDefaultCircle());
          renderFieldsets();
        }

        function removeCircle(fieldsetIndex, fieldIndex, circleIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field || !field.circles) return;
          field.circles.splice(circleIndex, 1);
          renderFieldsets();
        }

        function addRectangle(fieldsetIndex, fieldIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field) return;
          field.rectangles = field.rectangles || [];
          field.rectangles.push(createDefaultRectangle());
          renderFieldsets();
        }

        function removeRectangle(fieldsetIndex, fieldIndex, rectangleIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field || !field.rectangles) return;
          field.rectangles.splice(rectangleIndex, 1);
          renderFieldsets();
        }

        function resolveShape(meta) {
          if (!meta) return null;
          if (meta.isTriOrbShape) {
            return triorbShapes[meta.shapeIndex] || null;
          }
          const field = getFieldEntry(meta.fieldsetIndex, meta.fieldIndex);
          if (!field) {
            return null;
          }
          switch (meta.kind) {
            case "polygon":
              return field.polygons?.[meta.shapeIndex] || null;
            case "rectangle":
              return field.rectangles?.[meta.shapeIndex] || null;
            case "circle":
              return field.circles?.[meta.shapeIndex] || null;
            default:
              return null;
          }
        }

        function cloneShape(shape) {
          if (!shape) return null;
          return JSON.parse(JSON.stringify(shape));
        }

        function restoreShapeValues(target, source) {
          if (!target || !source) return;
          Object.keys(target).forEach((key) => {
            delete target[key];
          });
          Object.keys(source).forEach((key) => {
            target[key] = source[key];
          });
        }

        function renderShapeModal(meta) {
          const shape = resolveShape(meta);
          if (!shape) return;
          modalShapeMeta = meta;
          modalOriginalShape = cloneShape(shape);
          shapeModalTitle.textContent = `${meta.shapeType || meta.kind} Edit`;
          let html = "";
          if (meta.kind === "polygon") {
            const points = shape.points || [];
            html += points
              .map(
                (point, idx) => `
              <div class="modal-field">
                <label>Point ${idx + 1} X(mm)</label>
                <input type="number" data-point-index="${idx}" data-axis="X" value="${escapeHtml(
                  point.X ?? "0"
                )}" />
                <label>Point ${idx + 1} Y(mm)</label>
                <input type="number" data-point-index="${idx}" data-axis="Y" value="${escapeHtml(
                  point.Y ?? "0"
                )}" />
              </div>`
              )
              .join("");
          } else if (meta.kind === "rectangle") {
            ["OriginX", "OriginY", "Width", "Height", "Rotation"].forEach((key) => {
              html += `
              <div class="modal-field">
                <label>${key}(mm)</label>
                <input type="number" data-field="${key}" value="${escapeHtml(shape[key] ?? "0")}" />
              </div>`;
            });
          } else if (meta.kind === "circle") {
            ["CenterX", "CenterY", "Radius"].forEach((key) => {
              html += `
              <div class="modal-field">
                <label>${key}(mm)</label>
                <input type="number" data-field="${key}" value="${escapeHtml(shape[key] ?? "0")}" />
              </div>`;
            });
          }
          shapeModalBody.innerHTML = html;
          shapeModal.classList.add("active");
          shapeModal.setAttribute("aria-hidden", "false");
          ensureModalPosition();
        }

        function handleShapeModalInput(event) {
          if (!modalShapeMeta) {
            return;
          }
          const shape = resolveShape(modalShapeMeta);
          if (!shape) {
            return;
          }
          const input = event.target;
          if (!input) {
            return;
          }
          if (modalShapeMeta.kind === "polygon") {
            const pointIndex = Number(input.dataset.pointIndex);
            const axis = input.dataset.axis;
            if (Number.isFinite(pointIndex) && axis) {
              shape.points = shape.points || [];
              if (!shape.points[pointIndex]) {
                shape.points[pointIndex] = { X: "0", Y: "0" };
              }
              shape.points[pointIndex][axis] = input.value;
            }
          } else {
            const field = input.dataset.field;
            if (field) {
              shape[field] = input.value;
            }
          }
          renderFieldsets();
          renderFigure();
        }

        function closeShapeModal() {
          modalShapeMeta = null;
          modalOriginalShape = null;
          shapeModal.classList.remove("active");
          shapeModal.setAttribute("aria-hidden", "true");
        }

        function saveShapeModal() {
          if (!modalShapeMeta) {
            return;
          }
          const shape = resolveShape(modalShapeMeta);
          modalOriginalShape = cloneShape(shape);
          closeShapeModal();
        }

        function cancelShapeModal() {
          if (modalShapeMeta && modalOriginalShape) {
            const shape = resolveShape(modalShapeMeta);
            if (shape) {
              restoreShapeValues(shape, modalOriginalShape);
            }
          }
          renderFieldsets();
          renderFigure();
          closeShapeModal();
        }

        function ensureModalPosition() {
          if (shapeModalWindow) {
            shapeModalWindow.style.transform = `translate(${modalOffsetX}px, ${modalOffsetY}px)`;
          }
        }

        function startModalDrag(event) {
          if (!shapeModalWindow) return;
          isModalDragging = true;
          modalDragStartX = event.clientX;
          modalDragStartY = event.clientY;
          shapeModalWindow.style.transition = "none";
        }

        function updateModalDrag(event) {
          if (!isModalDragging) return;
          const dx = event.clientX - modalDragStartX;
          const dy = event.clientY - modalDragStartY;
          if (shapeModalWindow) {
            shapeModalWindow.style.transform = `translate(${modalOffsetX + dx}px, ${modalOffsetY + dy}px)`;
          }
        }

        function endModalDrag(event) {
          if (!isModalDragging) return;
          const dx = event.clientX - modalDragStartX;
          const dy = event.clientY - modalDragStartY;
          modalOffsetX += dx;
          modalOffsetY += dy;
          isModalDragging = false;
          if (shapeModalWindow) {
            shapeModalWindow.style.transition = "";
            ensureModalPosition();
          }
        }

        function formatAttributeBadges(attrs) {
          if (!attrs) {
            return "";
          }
          return Object.entries(attrs)
            .map(
              ([key, value]) =>
                `<span>${escapeHtml(key)}=${escapeHtml(value ?? "")}</span>`
            )
            .join("");
        }

        function initializeFieldsetDevices(data) {
          let devices;
          if (!Array.isArray(data) || !data.length) {
            devices = getDefaultFieldsetDevices();
          } else {
            devices = data.map((device, index) => {
              const attrs = { ...(device.attributes || {}) };
              if (!attrs.DeviceName) {
                const scanDeviceByName = findScanPlaneDeviceByName(attrs.DeviceName);
                if (scanDeviceByName?.attributes?.DeviceName) {
                  attrs.DeviceName = scanDeviceByName.attributes.DeviceName;
                } else {
                  const scanDevice = findScanPlaneDeviceByTypekey(attrs.Typekey);
                  if (scanDevice?.attributes?.DeviceName) {
                    attrs.DeviceName = scanDevice.attributes.DeviceName;
                  } else {
                    attrs.DeviceName = `Device ${index + 1}`;
                  }
                }
              }
              const wrapper = { attributes: attrs };
              applyScanPlaneDeviceAttributes(wrapper, {
                deviceName: attrs.DeviceName,
                typekey: attrs.Typekey,
              });
              return wrapper;
            });
          }
          ensureDefaultFieldsetDevices(devices);
          return devices;
        }

        function initializeGlobalGeometry(data) {
          if (!data || typeof data !== "object" || !Object.keys(data).length) {
            return { UseGlobalGeometry: "false" };
          }
          return { ...data };
        }

        function cloneGenericNode(node) {
          if (!node || typeof node !== "object") {
            return null;
          }
          const children = Array.isArray(node.children)
            ? node.children.map((child) => cloneGenericNode(child)).filter(Boolean)
            : [];
          return {
            tag: node.tag || "Node",
            attributes: { ...(node.attributes || {}) },
            text: typeof node.text === "string" ? node.text : "",
            children,
          };
        }

        function normalizeCasetableConfiguration(node) {
          const cloned = cloneGenericNode(node);
          if (cloned) {
            return cloned;
          }
          return createDefaultCasetableConfiguration();
        }

        function createDefaultCasetableConfiguration() {
          return { tag: "Configuration", attributes: {}, text: "", children: [] };
        }

        function normalizeCasetableLayout(layoutEntries) {
          const normalized = [];
          if (Array.isArray(layoutEntries)) {
            layoutEntries.forEach((entry) => {
              if (!entry || typeof entry !== "object") {
                return;
              }
              if (entry.kind === "node" && entry.node) {
                normalized.push({ kind: "node", node: cloneGenericNode(entry.node) });
              } else if (
                entry.kind === "configuration" ||
                entry.kind === "cases" ||
                entry.kind === "evals" ||
                entry.kind === "fields_configuration"
              ) {
                if (!normalized.some((item) => item.kind === entry.kind)) {
                  normalized.push({ kind: entry.kind });
                }
              }
            });
          }
          ["configuration", "cases", "evals", "fields_configuration"].forEach((kind) => {
            if (!normalized.some((entry) => entry.kind === kind)) {
              normalized.push({ kind });
            }
          });
          return normalized;
        }

        function normalizeCaseLayout(layoutEntries, staticInputs, speedActivation) {
          const layout = [];
          if (Array.isArray(layoutEntries)) {
            layoutEntries.forEach((segment) => {
              if (!segment || typeof segment !== "object") {
                return;
              }
              if (segment.kind === "node" && segment.node) {
                layout.push({ kind: "node", node: cloneGenericNode(segment.node) });
              } else if (segment.kind === "static-inputs") {
                if (!layout.some((entry) => entry.kind === "static-inputs")) {
                  layout.push({ kind: "static-inputs" });
                }
              } else if (segment.kind === "speed-activation") {
                if (!layout.some((entry) => entry.kind === "speed-activation")) {
                  layout.push({ kind: "speed-activation" });
                }
              }
            });
          }
          if (staticInputs?.length && !layout.some((entry) => entry.kind === "static-inputs")) {
            layout.push({ kind: "static-inputs" });
          }
          if (speedActivation && !layout.some((entry) => entry.kind === "speed-activation")) {
            layout.push({ kind: "speed-activation" });
          }
          return layout;
        }

        function initializeCasetableCases(data) {
          if (!Array.isArray(data) || !data.length) {
            return [createDefaultCasetableCase(0)];
          }
          return data
            .slice(0, casetableCasesLimit)
            .map((entry, index) => normalizeCasetableCase(entry, index));
        }

        function normalizeCasetableCase(entry, index) {
          const attributes = { ...(entry?.attributes || {}) };
          if (!attributes.Name) {
            attributes.Name = buildCaseName(index);
          }
          const staticInputs = normalizeStaticInputs(entry?.static_inputs);
          const speedActivation = normalizeSpeedActivation(entry?.speed_activation);
          const layout = normalizeCaseLayout(entry?.layout, staticInputs, speedActivation);
          return { attributes, staticInputs, speedActivation, layout };
        }

        function buildCaseName(index) {
          return `Case ${index + 1}`;
        }

        function createDefaultCasetableCase(index = 0) {
          const attributes = {
            Name: buildCaseName(index),
            NameLatin9Key: `_CASE_${String(index + 1).padStart(3, "0")}`,
          };
          const staticInputs = [createDefaultStaticInput(`StaticInput ${index + 1}`)];
          const speedActivation = normalizeSpeedActivation({ attributes: { Mode: "Off" }, mode_key: "Mode" });
          const layout = normalizeCaseLayout(null, staticInputs, speedActivation);
          return { attributes, staticInputs, speedActivation, layout };
        }

        function createDefaultStaticInput(name) {
          return {
            attributes: { Name: name || "StaticInput", State: "Low" },
            valueKey: "State",
          };
        }

        function resolveStaticInputValueKey(attrs) {
          const candidates = ["Value", "State", "Level", "Mode"];
          for (const candidate of candidates) {
            if (candidate in (attrs || {})) {
              return candidate;
            }
          }
          return "Value";
        }

        function resolveSpeedActivationKey(attrs) {
          const candidates = ["Mode", "Type", "State", "Value"];
          for (const candidate of candidates) {
            if (candidate in (attrs || {})) {
              return candidate;
            }
          }
          return "Mode";
        }

        function normalizeStaticInputs(list) {
          if (!Array.isArray(list) || !list.length) {
            return [createDefaultStaticInput("StaticInput")];
          }
          return list.map((item, index) => {
            const attributes = { ...(item?.attributes || {}) };
            if (!attributes.Name) {
              attributes.Name = `StaticInput ${index + 1}`;
            }
            const valueKey = item?.value_key || resolveStaticInputValueKey(attributes);
            if (!(valueKey in attributes)) {
              attributes[valueKey] = "Low";
            }
            return { attributes, valueKey };
          });
        }

        function normalizeSpeedActivation(entry) {
          const attributes = { ...(entry?.attributes || {}) };
          const modeKey = entry?.mode_key || resolveSpeedActivationKey(attributes);
          if (!(modeKey in attributes)) {
            attributes[modeKey] = "Off";
          }
          return { attributes, modeKey };
        }

        function findCasetableConfigNode(path) {
          if (!path) {
            return null;
          }
          if (path === "root") {
            return casetableConfiguration;
          }
          const parts = path.split(".");
          let node = casetableConfiguration;
          for (let index = 1; index < parts.length; index += 1) {
            const childIndex = Number(parts[index]);
            if (Number.isNaN(childIndex) || !node?.children?.[childIndex]) {
              return null;
            }
            node = node.children[childIndex];
          }
          return node;
        }

        function updateCasetableConfigAttribute(path, field, value) {
          if (!field) {
            return;
          }
          const node = findCasetableConfigNode(path);
          if (!node) {
            return;
          }
          node.attributes = node.attributes || {};
          node.attributes[field] = value;
        }

        function updateCasetableConfigText(path, value) {
          const node = findCasetableConfigNode(path);
          if (!node) {
            return;
          }
          node.text = value;
        }

        function updateCaseAttribute(caseIndex, field, value) {
          const caseData = casetableCases[caseIndex];
          if (!caseData || !field) {
            return;
          }
          caseData.attributes[field] = value;
          if (field === "Name") {
            const summary = casetableCasesContainer?.querySelector(
              `.casetable-case-card[data-case-index="${caseIndex}"] .casetable-case-summary`
            );
            if (summary) {
              summary.textContent = value || buildCaseName(caseIndex);
            }
          }
        }

        function updateStaticInputValue(caseIndex, staticIndex, value) {
          const caseData = casetableCases[caseIndex];
          if (!caseData) {
            return;
          }
          const staticEntry = caseData.staticInputs?.[staticIndex];
          if (!staticEntry) {
            return;
          }
          const key = staticEntry.valueKey || resolveStaticInputValueKey(staticEntry.attributes || {});
          staticEntry.valueKey = key;
          staticEntry.attributes[key] = value;
        }

        function updateSpeedActivationValue(caseIndex, value) {
          const caseData = casetableCases[caseIndex];
          if (!caseData || !caseData.speedActivation) {
            return;
          }
          const key =
            caseData.speedActivation.modeKey ||
            resolveSpeedActivationKey(caseData.speedActivation.attributes || {});
          caseData.speedActivation.modeKey = key;
          caseData.speedActivation.attributes[key] = value;
        }

        function createDefaultFieldsetDevice(index = 0, overrides = {}) {
          const options = getScanPlaneDeviceOptions();
          const fallbackOption =
            options[Math.min(index, Math.max(0, options.length - 1))] ||
            options[0];
          const defaultTypekey =
            fallbackOption?.typekey || "NANS3-CAAZ30ZA1P02";
          const optionLabel = (fallbackOption?.label || "").trim();
          const optionName = optionLabel.includes("(")
            ? optionLabel.split("(")[0].trim()
            : optionLabel;
          const templateName =
            defaultFieldsetDeviceTemplates[index]?.DeviceName || "";
          const resolvedName =
            overrides.DeviceName ||
            optionName ||
            templateName ||
            `Device ${index + 1}`;
          const device = {
            attributes: {
              DeviceName: resolvedName,
              Typekey: defaultTypekey,
              TypekeyVersion: fallbackOption?.typekeyVersion || "1.0",
              TypekeyDisplayVersion:
                fallbackOption?.typekeyDisplayVersion || "V 1.0.0",
              PositionX: "0",
              PositionY: "0",
              Rotation: "0",
              StandingUpsideDown: "false",
              ...overrides,
            },
          };
          applyScanPlaneDeviceAttributes(device, {
            deviceName: resolvedName,
            typekey: defaultTypekey,
          });
          return device;
        }

        function getDefaultFieldsetDevices() {
          if (!defaultFieldsetDeviceTemplates.length) {
            return [createDefaultFieldsetDevice(0)];
          }
          return defaultFieldsetDeviceTemplates.map((template, index) =>
            createDefaultFieldsetDevice(index, template)
          );
        }

        function ensureDefaultFieldsetDevices(devices) {
          if (!Array.isArray(devices)) {
            return;
          }
          defaultFieldsetDeviceTemplates.forEach((template) => {
            const exists = devices.some(
              (device) =>
                device.attributes?.PositionX === template.PositionX &&
                device.attributes?.PositionY === template.PositionY &&
                device.attributes?.Rotation === template.Rotation
            );
            if (!exists) {
              devices.push(createDefaultFieldsetDevice(devices.length, template));
            }
          });
        }

        function renderFieldsetDevices() {
          if (!fieldsetDevicesContainer) return;
          if (!fieldsetDevices.length) {
            fieldsetDevicesContainer.innerHTML = "<p>No devices defined.</p>";
            return;
          }
          const deviceOptions = getScanPlaneDeviceOptions();
          fieldsetDevicesContainer.innerHTML = fieldsetDevices
            .map((device, deviceIndex) => {
              const attributeEntries = Object.entries(device.attributes || {});
              const deviceFields = attributeEntries
                .map(([key, value]) => {
                  if (key === "DeviceName") {
                    const selectionExists = deviceOptions.some(
                      (opt) => opt.deviceName === value
                    );
                    const optionsHtml =
                      '<option value="">-- Select Device --</option>' +
                      (deviceOptions.length
                        ? deviceOptions
                            .map(
                              (opt) =>
                                `<option value="${escapeHtml(opt.deviceName)}"${
                                  opt.deviceName === value ? " selected" : ""
                                }>${escapeHtml(opt.label)}</option>`
                            )
                            .join("")
                        : "");
                    const fallbackOption =
                      !selectionExists && value
                        ? `<option value="${escapeHtml(value)}" selected>${escapeHtml(
                            value
                          )}</option>`
                        : "";
                    return `
              <div class="device-field">
                <label>DeviceName</label>
                <select
                  class="fieldset-device-name"
                  data-device-index="${deviceIndex}"
                >
                  ${optionsHtml}${fallbackOption}
                </select>
              </div>`;
                  }
                  if (key === "Typekey") {
                    return `
              <div class="device-field">
                <label>${escapeHtml(key)}</label>
                <input type="text" value="${escapeHtml(value ?? "")}" readonly />
              </div>`;
                  }
                  if (["TypekeyDisplayVersion", "TypekeyVersion"].includes(key)) {
                    return `
              <div class="device-field">
                <label>${escapeHtml(key)}</label>
                <input type="text" value="${escapeHtml(value ?? "")}" readonly />
              </div>`;
                  }
                  return `
              <div class="device-field">
                <label>${escapeHtml(key)}</label>
                <input
                  type="text"
                  class="fieldset-device-attr"
                  data-device-index="${deviceIndex}"
                  data-field="${escapeHtml(key)}"
                  value="${escapeHtml(value ?? "")}"
                />
              </div>`;
                })
                .join("");

              return `
            <div class="device-card" data-fieldset-device-index="${deviceIndex}">
              <details class="device-details" open>
                <summary>
                  <span>Device #${deviceIndex + 1}</span>
                  <span class="device-summary">${device.attributes.Typekey || ""}</span>
                  <button
                    type="button"
                    class="inline-btn inline-danger"
                    data-action="remove-fieldset-device"
                    data-device-index="${deviceIndex}"
                  >
                    Remove
                  </button>
                </summary>
                <div class="device-fields">${deviceFields}</div>
              </details>
            </div>`;
            })
            .join("");
        }

        function renderFieldsetGlobal() {
          if (!fieldsetGlobalContainer) return;
          const entries =
            Object.entries(fieldsetGlobalGeometry || {}).length > 0
              ? Object.entries(fieldsetGlobalGeometry)
              : [["UseGlobalGeometry", "false"]];
          fieldsetGlobalContainer.innerHTML = entries
            .map(
              ([key, value]) => `
          <div class="fieldset-field">
            <label>${escapeHtml(key)}</label>
            <input
              type="text"
              class="fieldset-global-attr"
              data-field="${escapeHtml(key)}"
              value="${escapeHtml(value ?? "")}"
            />
          </div>`
            )
            .join("");
        }

        function updateFieldsetDeviceAttribute(deviceIndex, key, value) {
          const device = fieldsetDevices[deviceIndex];
          if (!device) return;
          device.attributes[key] = value;
          if (key === "Typekey") {
            const summary = document.querySelector(
              `.device-card[data-fieldset-device-index="${deviceIndex}"] .device-summary`
            );
            if (summary) {
              summary.textContent = value;
            }
          }
          renderFigure();
        }

        function updateGlobalGeometryAttribute(key, value) {
          fieldsetGlobalGeometry[key] = value;
        }

        function buildBaseSdImportExportLines({ scanDeviceAttrs = null, fieldsetDeviceAttrs = null } = {}) {
          const figure = currentFigure || defaultFigure;
          const fileInfoLines = buildFileInfoLines();
          const scanPlaneLines = buildScanPlanesXml(scanDeviceAttrs);
          const fieldsetLines = buildFieldsetsXml(fieldsetDeviceAttrs);
          const casetableLines = buildCasetablesXml();
          const rootAttrOverrides = {
            ...rootAttributes,
            Timestamp: new Date().toISOString(),
            "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
            "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
          };
          const rootAttrText = buildRootAttributes(
            rootAttrOverrides,
            getAttributeOrder("SdImportExport")
          );
          const lines = [
            '<?xml version="1.0" encoding="utf-8"?>',
            rootAttrText ? `<SdImportExport ${rootAttrText}>` : "<SdImportExport>",
            "  <FileInfo>",
            ...fileInfoLines,
            "  </FileInfo>",
            "  <Export_ScanPlanes>",
            ...scanPlaneLines,
            "  </Export_ScanPlanes>",
            "  <Export_FieldsetsAndFields>",
            ...fieldsetLines,
            "  </Export_FieldsetsAndFields>",
            "  <Export_CasetablesAndCases>",
            ...casetableLines,
            "  </Export_CasetablesAndCases>",
            "</SdImportExport>",
          ];
          return lines;
        }

        function buildLegacyXml() {
          const lines = buildBaseSdImportExportLines();
          return lines.join("\n");
        }

        function buildTriOrbXml() {
          const lines = buildBaseSdImportExportLines().slice();
          lines.push("");
          if (!triorbSource) {
            triorbSource = "TriOrbAware";
          }
          const sourceAttr = triorbSource
            ? ` Source="${escapeXml(triorbSource)}"`
            : "";
          lines.push(`<TriOrb_SICK_SLS_Editor${sourceAttr}>`);
          lines.push("  <PlotlyData>");
          lines.push("    <Traces>");

          const figure = currentFigure || defaultFigure;
          (figure.data || []).forEach((trace, index) => {
            const name = escapeXml(trace?.name ?? `Trace ${index + 1}`);
            const mode = escapeXml(trace?.mode ?? "lines");
            lines.push(`      <Trace Name="${name}" Mode="${mode}">`);
            const len = Math.min(trace.x?.length || 0, trace.y?.length || 0);
            for (let i = 0; i < len; i += 1) {
              lines.push(`        <Point X="${trace.x[i]}" Y="${trace.y[i]}" />`);
            }
            lines.push("      </Trace>");
          });

          lines.push("    </Traces>");
          lines.push("  </PlotlyData>");
          lines.push("  <TriOrbMenu>");
          lines.push(
            `    <Device FieldOfView="${escapeXml(String(fieldOfViewDegrees || "270"))}" />`
          );
          lines.push(
            `    <Field MultipleSampling="${escapeXml(
              String(globalMultipleSampling || "2")
            )}">`
          );
          lines.push("      <CommonCutOut Name=\"CommonCutOut #1\">");
          lines.push("        <Polygon Name=\"Polygon #1\" />");
          lines.push("        <Circle Name=\"Circle #1\" />");
          lines.push("        <Rectangle Name=\"Rectangle #1\" />");
          lines.push("      </CommonCutOut>");
          lines.push("    </Field>");
          const shapeLines = buildTriOrbShapesXml();
          shapeLines.forEach((line) => lines.push(line));
          lines.push("  </TriOrbMenu>");
          lines.push("</TriOrb_SICK_SLS_Editor>");
          return lines.join("\n");
        }

        function buildDeviceAttributeString(attrs, { keepDeviceName = false } = {}) {
          if (!attrs) return "";
          const sanitized = { ...attrs };
          if (!keepDeviceName) {
            delete sanitized.DeviceName;
          }
          return buildAttributeString(sanitized, getAttributeOrder("Device"));
        }

        function formatDeviceFilePrefix(attrs, index) {
          const rawName = (attrs?.DeviceName || "").trim() || attrs?.Typekey || `device${index + 1}`;
          return rawName.replace(/[^a-zA-Z0-9._-]/g, "_");
        }

        function buildScanPlanesXml(scanDeviceAttrs = null) {
          if (!scanPlanes.length) {
            return ["    <!-- ScanPlane not set -->"];
          }
          const lines = [];
          scanPlanes.forEach((plane) => {
            const attrText = buildAttributeString(
              plane.attributes,
              getAttributeOrder("ScanPlane")
            );
            lines.push(`    <ScanPlane${attrText ? " " + attrText : ""}>`);
            const devicesToRender = scanDeviceAttrs
              ? [{ attributes: scanDeviceAttrs }]
              : plane.devices || [];
            lines.push("      <Devices>");
            if (devicesToRender.length) {
              devicesToRender.forEach((device) => {
                const attrs = buildDeviceAttributeString(device.attributes, {
                  keepDeviceName: true,
                });
                lines.push(`        <Device${attrs ? " " + attrs : ""} />`);
              });
            } else {
              lines.push("        <!-- No devices -->");
            }
            lines.push("      </Devices>");
            lines.push("    </ScanPlane>");
          });
          return lines;
        }

        function buildFieldsetsXml(fieldsetDeviceAttrs = null) {
          const lines = [];
          lines.push('    <ScanPlane Index="0">');

          lines.push("      <Devices>");
          const devicesToRender = fieldsetDeviceAttrs
            ? [{ attributes: fieldsetDeviceAttrs }]
            : fieldsetDevices;
          if (devicesToRender && devicesToRender.length) {
            devicesToRender.forEach((device) => {
              const deviceAttrs = buildDeviceAttributeString(device.attributes, {
                keepDeviceName: false,
              });
              lines.push(`        <Device${deviceAttrs ? " " + deviceAttrs : ""} />`);
            });
          } else {
            lines.push("        <!-- No devices -->");
          }
          lines.push("      </Devices>");

          const globalAttr = buildAttributeString(
            fieldsetGlobalGeometry,
            getAttributeOrder("GlobalGeometry")
          );
          lines.push(
            globalAttr
              ? `      <GlobalGeometry ${globalAttr} />`
              : "      <GlobalGeometry />"
          );

          lines.push("      <Fieldsets>");
          if (fieldsets.length) {
            fieldsets.forEach((fieldset) => {
              const attrText = buildAttributeString(
                fieldset.attributes,
                getAttributeOrder("Fieldset")
              );
              lines.push(`        <Fieldset${attrText ? " " + attrText : ""}>`);
              if (fieldset.fields && fieldset.fields.length) {
                fieldset.fields.forEach((field) => {
                  const fieldAttrs = buildAttributeString(
                    field.attributes,
                    getAttributeOrder("Field")
                  );
                  lines.push(`          <Field${fieldAttrs ? " " + fieldAttrs : ""}>`);
                  if (field.shapeRefs && field.shapeRefs.length) {
                    field.shapeRefs.forEach((shapeRef) => {
                      const shape = findTriOrbShapeById(shapeRef.shapeId);
                      if (!shape) {
                        return;
                      }
                      if (shape.type === "Polygon" && shape.polygon) {
                        const polygonAttr = buildAttributeString(
                          { Type: getPolygonTypeValue(shape.polygon) },
                          getAttributeOrder("Polygon")
                        );
                        lines.push(
                          `            <Polygon${polygonAttr ? " " + polygonAttr : ""}>`
                        );
                        (shape.polygon.points || []).forEach((point) => {
                          const pointAttrs = buildAttributeString(
                            point,
                            getAttributeOrder("Point")
                          );
                          lines.push(
                            `              <Point${pointAttrs ? " " + pointAttrs : ""} />`
                          );
                        });
                        lines.push("            </Polygon>");
                      } else if (shape.type === "Rectangle" && shape.rectangle) {
                        const rectAttrs = buildAttributeString(
                          shape.rectangle,
                          getAttributeOrder("Rectangle")
                        );
                        lines.push(
                          `            <Rectangle${rectAttrs ? " " + rectAttrs : ""} />`
                        );
                      } else if (shape.type === "Circle" && shape.circle) {
                        const circleAttrs = buildAttributeString(
                          shape.circle,
                          getAttributeOrder("Circle")
                        );
                        lines.push(
                          `            <Circle${circleAttrs ? " " + circleAttrs : ""} />`
                        );
                      }
                    });
                  } else {
                    lines.push("            <!-- No shapes assigned -->");
                  }
                  lines.push("          </Field>");
                });
              } else {
                lines.push("          <!-- No fields -->");
              }
              lines.push("        </Fieldset>");
            });
          } else {
            lines.push("        <!-- No fieldsets -->");
          }
          lines.push("      </Fieldsets>");
          lines.push("    </ScanPlane>");
          return lines;
        }

        function buildGenericNodeLines(node, indentLevel = 0) {
          if (!node || !node.tag) {
            return [];
          }
          const indent = "  ".repeat(indentLevel);
          const attrText = buildRootAttributes(node.attributes, getAttributeOrder(node.tag));
          const hasChildren = Array.isArray(node.children) && node.children.length;
          const hasText = typeof node.text === "string" && node.text.length;
          if (!hasChildren && !hasText) {
            return [`${indent}<${sanitizeTagName(node.tag)}${attrText ? ` ${attrText}` : ""} />`];
          }
          const lines = [
            `${indent}<${sanitizeTagName(node.tag)}${attrText ? ` ${attrText}` : ""}>`,
          ];
          if (hasText) {
            lines.push(`${indent}  ${escapeXml(node.text)}`);
          }
          if (hasChildren) {
            node.children.forEach((child) => {
              lines.push(...buildGenericNodeLines(child, indentLevel + 1));
            });
          }
          lines.push(`${indent}</${sanitizeTagName(node.tag)}>`);
          return lines;
        }

        function buildStaticInputsLines(staticInputs, indentLevel) {
          const indent = "  ".repeat(indentLevel);
          const lines = [`${indent}<StaticInputs>`];
          if (staticInputs && staticInputs.length) {
            staticInputs.forEach((input) => {
              const attrs = buildRootAttributes(
                input.attributes,
                getAttributeOrder("StaticInput")
              );
              lines.push(`${indent}  <StaticInput${attrs ? ` ${attrs}` : ""} />`);
            });
          } else {
            lines.push(`${indent}  <!-- No StaticInput -->`);
          }
          lines.push(`${indent}</StaticInputs>`);
          return lines;
        }

        function buildSpeedActivationLines(speedActivation, indentLevel) {
          const indent = "  ".repeat(indentLevel);
          if (!speedActivation) {
            return [`${indent}<SpeedActivation Mode="Off" />`];
          }
          const attrs = buildRootAttributes(
            speedActivation.attributes,
            getAttributeOrder("SpeedActivation")
          );
          return [`${indent}<SpeedActivation${attrs ? ` ${attrs}` : ""} />`];
        }

        function deriveCaseLayout(caseData) {
          const layout = [];
          if (Array.isArray(caseData.layout)) {
            caseData.layout.forEach((segment) => {
              if (!segment || typeof segment !== "object") {
                return;
              }
              if (segment.kind === "node" && segment.node) {
                layout.push({ kind: "node", node: cloneGenericNode(segment.node) });
              } else if (
                segment.kind === "static-inputs" ||
                segment.kind === "speed-activation"
              ) {
                if (!layout.some((entry) => entry.kind === segment.kind)) {
                  layout.push({ kind: segment.kind });
                }
              }
            });
          }
          if (caseData.staticInputs?.length && !layout.some((entry) => entry.kind === "static-inputs")) {
            layout.push({ kind: "static-inputs" });
          }
          if (caseData.speedActivation && !layout.some((entry) => entry.kind === "speed-activation")) {
            layout.push({ kind: "speed-activation" });
          }
          return layout;
        }

        function extractCaseNodeText(caseData, tagName) {
          if (!caseData || !Array.isArray(caseData.layout)) {
            return null;
          }
          const targetTag = (tagName || "").trim();
          for (const segment of caseData.layout) {
            if (segment?.kind !== "node" || !segment.node) {
              continue;
            }
            if (segment.node.tag === targetTag) {
              if (typeof segment.node.text === "string") {
                return segment.node.text;
              }
              return "";
            }
          }
          return null;
        }

        function buildCaseLines(caseData, caseIndex, indentLevel = 4) {
          const indent = "  ".repeat(indentLevel);
          const childIndent = "  ".repeat(indentLevel + 1);
          const attrs = { ...(caseData.attributes || {}) };
          attrs.Id = String(caseIndex);
          delete attrs.DisplayOrder;
          delete attrs.Name;
          delete attrs.NameLatin9Key;
          const attrText = buildRootAttributes(attrs, getAttributeOrder("Case"));
          const lines = [`${indent}<Case${attrText ? ` ${attrText}` : ""}>`];
          const layout = deriveCaseLayout(caseData);
          const childLines = [];
          const caseNameValue =
            extractCaseNodeText(caseData, "Name") ??
            caseData.attributes?.Name ??
            buildCaseName(caseIndex);
          const latin9Value =
            extractCaseNodeText(caseData, "NameLatin9Key") ??
            caseData.attributes?.NameLatin9Key ??
            "";
          const displayOrderValue =
            extractCaseNodeText(caseData, "DisplayOrder") ??
            caseData.attributes?.DisplayOrder ??
            String(caseIndex);
          let hasNameNode = false;
          let hasLatinNode = false;
          let hasDisplayOrderNode = false;
          layout.forEach((segment) => {
            if (segment.kind === "node" && segment.node) {
              if (segment.node.tag === "Name") {
                hasNameNode = true;
                childLines.push(`${childIndent}<Name>${escapeXml(caseNameValue)}</Name>`);
              } else if (segment.node.tag === "NameLatin9Key") {
                hasLatinNode = true;
                childLines.push(`${childIndent}<NameLatin9Key>${escapeXml(latin9Value)}</NameLatin9Key>`);
              } else if (segment.node.tag === "DisplayOrder") {
                hasDisplayOrderNode = true;
                childLines.push(`${childIndent}<DisplayOrder>${escapeXml(displayOrderValue)}</DisplayOrder>`);
              } else {
                childLines.push(...buildGenericNodeLines(segment.node, indentLevel + 1));
              }
            }
          });
          const leadingNodes = [];
          if (!hasNameNode) {
            leadingNodes.push(`${childIndent}<Name>${escapeXml(caseNameValue)}</Name>`);
          }
          if (!hasLatinNode) {
            leadingNodes.push(`${childIndent}<NameLatin9Key>${escapeXml(latin9Value)}</NameLatin9Key>`);
          }
          if (!hasDisplayOrderNode) {
            leadingNodes.push(`${childIndent}<DisplayOrder>${escapeXml(displayOrderValue)}</DisplayOrder>`);
          }
          lines.push(...leadingNodes, ...childLines);
          lines.push(`${indent}</Case>`);
          return lines;
        }

        function buildCasetablesXml() {
          const lines = [];
          const attrs = { ...(casetableAttributes || {}) };
          if (!("Index" in attrs)) {
            attrs.Index = "0";
          }
          const attrText = buildRootAttributes(attrs, getAttributeOrder("Casetable"));
          const layout =
            Array.isArray(casetableLayout) && casetableLayout.length
              ? casetableLayout
              : normalizeCasetableLayout([]);
          lines.push(`    <Casetable${attrText ? ` ${attrText}` : ""}>`);
          layout.forEach((segment) => {
            if (segment.kind === "configuration") {
              if (casetableConfiguration) {
                lines.push(...buildGenericNodeLines(casetableConfiguration, 3));
              } else {
                lines.push("      <Configuration />");
              }
            } else if (segment.kind === "cases") {
              lines.push("      <Cases>");
              if (casetableCases.length) {
                casetableCases.forEach((caseData, index) => {
                  lines.push(...buildCaseLines(caseData, index, 4));
                });
              } else {
                lines.push("        <!-- No cases defined -->");
              }
              lines.push("      </Cases>");
            } else if (segment.kind === "evals") {
              if (casetableEvals) {
                lines.push(...buildGenericNodeLines(casetableEvals, 3));
              } else {
                lines.push("      <Evals />");
              }
            } else if (segment.kind === "fields_configuration") {
              if (casetableFieldsConfiguration) {
                lines.push(...buildGenericNodeLines(casetableFieldsConfiguration, 3));
              } else {
                lines.push("      <FieldsConfiguration />");
              }
            } else if (segment.kind === "node" && segment.node) {
              lines.push(...buildGenericNodeLines(segment.node, 3));
            }
          });
          lines.push("    </Casetable>");
          return lines;
        }

        function buildAttributeString(attrs, order = []) {
          if (!attrs) return "";
          const keys = Object.keys(attrs);
          const orderedKeys = [];
          const remaining = new Set(keys);
          order.forEach((key) => {
            if (remaining.has(key)) {
              orderedKeys.push(key);
              remaining.delete(key);
            }
          });
          Array.from(remaining)
            .sort()
            .forEach((key) => orderedKeys.push(key));
          return orderedKeys
            .map(
              (key) =>
                `${sanitizeTagName(key)}="${escapeXml(String(attrs[key] ?? ""))}"`
            )
            .join(" ");
        }

        function getAttributeOrder(tag) {
          switch (tag) {
            case "SdImportExport":
              return ["Timestamp", "xmlns:xsd", "xmlns:xsi"];
            case "ScanPlane":
              return [
                "Index",
                "Name",
                "ScanPlaneDirection",
                "UseReferenceContour",
                "ObjectSize",
                "MultipleSampling",
                "MultipleSamplingOff2OnActivated",
                "SelectedCaseSwitching",
              ];
            case "Device":
              return [
                "Index",
                "Typekey",
                "TypekeyVersion",
                "TypekeyDisplayVersion",
                "DeviceName",
                "ResponseTime",
                "ScanResolutionAddition",
                "PositionX",
                "PositionY",
                "Rotation",
                "StandingUpsideDown",
              ];
            case "Fieldset":
              return ["Name", "NameLatin9Key"];
            case "Field":
              return [
                "Name",
                "Fieldtype",
                "MultipleSampling",
                "Resolution",
                "TolerancePositive",
                "ToleranceNegative",
              ];
            case "Casetable":
              return ["Index", "Name"];
            case "Case":
              return ["Id", "DisplayOrder", "Name", "NameLatin9Key"];
            case "StaticInput":
              return ["Name", "State", "Value"];
            case "SpeedActivation":
              return ["Mode", "Type"];
            case "Polygon":
              return ["Type"];
            case "Rectangle":
              return ["Type", "OriginX", "OriginY", "Height", "Width", "Rotation"];
            case "Circle":
              return ["Type", "CenterX", "CenterY", "Radius"];
            case "Point":
              return ["X", "Y"];
            case "GlobalGeometry":
              return ["UseGlobalGeometry"];
            default:
              return [];
          }
        }

        function buildTriOrbShapesXml() {
          if (!Array.isArray(triorbShapes) || !triorbShapes.length) {
            return ["    <!-- No TriOrb shapes -->"];
          }
          const lines = [];
          lines.push("    <Shapes>");
          triorbShapes.forEach((shape) => {
            const shapeAttrs = buildAttributeString(
              { ID: shape.id, Name: shape.name, Type: shape.type, Fieldtype: shape.fieldtype, Kind: shape.kind },
              ["ID", "Name", "Type", "Fieldtype", "Kind"]
            );
            lines.push(`      <Shape${shapeAttrs ? " " + shapeAttrs : ""}>`);
            if (shape.type === "Polygon" && shape.polygon) {
              const polygonAttr = buildAttributeString(
                { Type: getPolygonTypeValue(shape.polygon) },
                ["Type"]
              );
              lines.push(`        <Polygon${polygonAttr ? " " + polygonAttr : ""}>`);
              (shape.polygon.points || []).forEach((point) => {
                const pointAttrs = buildAttributeString(point, getAttributeOrder("Point"));
                lines.push(`          <Point${pointAttrs ? " " + pointAttrs : ""} />`);
              });
              lines.push("        </Polygon>");
            } else if (shape.type === "Rectangle" && shape.rectangle) {
              const rectAttrs = buildAttributeString(
                shape.rectangle,
                getAttributeOrder("Rectangle")
              );
              lines.push(`        <Rectangle${rectAttrs ? " " + rectAttrs : ""} />`);
            } else if (shape.type === "Circle" && shape.circle) {
              const circleAttrs = buildAttributeString(shape.circle, getAttributeOrder("Circle"));
              lines.push(`        <Circle${circleAttrs ? " " + circleAttrs : ""} />`);
            }
            lines.push("      </Shape>");
          });
          lines.push("    </Shapes>");
          return lines;
        }

        function downloadXml(xmlString, filename) {
          const blob = new Blob([xmlString], { type: "application/xml" });
          const url = URL.createObjectURL(blob);
          const anchor = document.createElement("a");
          anchor.href = url;
          anchor.download = filename || `plot_${Date.now()}.sgexml`;
          document.body.appendChild(anchor);
          anchor.click();
          document.body.removeChild(anchor);
          URL.revokeObjectURL(url);
        }

        function escapeXml(value) {
          return String(value ?? "").replace(/[<>&'\"]/g, (char) => {
            switch (char) {
              case "<":
                return "&lt;";
              case ">":
                return "&gt;";
              case "&":
                return "&amp;";
              case "'":
                return "&apos;";
              case "\"":
                return "&quot;";
              default:
                return char;
            }
          });
        }

        function escapeHtml(value) {
          return String(value ?? "").replace(/[&<>"']/g, (char) => {
            switch (char) {
              case "&":
                return "&amp;";
              case "<":
                return "&lt;";
              case ">":
                return "&gt;";
              case '"':
                return "&quot;";
              case "'":
                return "&#39;";
              default:
                return char;
            }
          });
        }

        function sanitizeTagName(name) {
          return (name || "Field").replace(/[^\w:.-]/g, "_");
        }

        function buildFileInfoLines() {
          const scope = document.querySelector('[data-scope="fileinfo"]');
          if (!scope) {
            return ["    <!-- FileInfo not set -->"];
          }
          const inputs = Array.from(
            scope.querySelectorAll(
              ".menu-fileinfo-field input, .menu-fileinfo-field textarea"
            )
          );
          if (!inputs.length) {
            return ["    <!-- FileInfo not set -->"];
          }
          return inputs.map((input) => {
            const tag = sanitizeTagName(input.dataset.field || input.id || "Field");
            const rawValue = (input.value || "").trim();
            if (!rawValue) {
              return `    <${tag} />`;
            }
            const value = escapeXml(rawValue);
            return `    <${tag}>${value}</${tag}>`;
          });
        }

        function buildRootAttributes(attrs) {
          if (!attrs || typeof attrs !== "object") {
            return "";
          }
          return Object.entries(attrs)
            .map(
              ([key, value]) =>
                `${sanitizeTagName(key)}="${escapeXml(String(value ?? ""))}"`
            )
            .join(" ");
        }

        function buildRootAttributes(attrs, order = []) {
          if (!attrs || typeof attrs !== "object") {
            return "";
          }
          return buildAttributeString(attrs, order);
        }

        function parseXmlToFigure(xmlText) {
          const parser = new DOMParser();
          let doc = parser.parseFromString(xmlText, "application/xml");
          let sanitized = xmlText.replace(/<\?xml[^>]*\?>/gi, "").trim();
          let wrapperText = `<TriOrbWrapper>${sanitized}</TriOrbWrapper>`;
          let triOrbDoc = parser.parseFromString(wrapperText, "application/xml");
          if (doc.querySelector("parsererror")) {
            const wrapped = wrapperText;
            doc = parser.parseFromString(wrapped, "application/xml");
          }
          if (doc.querySelector("parsererror")) {
            throw new Error("Failed to parse XML.");
          }
          console.log("parseXmlToFigure TriOrb root exists", Boolean(doc.querySelector("TriOrb_SICK_SLS_Editor")));

          populateFileInfoFromDoc(doc);
          populateScanPlanesFromDoc(doc);
          populateTriOrbShapesFromDoc(triOrbDoc);
          populateFieldsetsFromDoc(doc);
          populateCasetablesFromDoc(doc);

          const tracesFromPlotData = parsePlotDataTraces(doc);
          if (tracesFromPlotData.length) {
            const triOrbPresent = Boolean(triOrbDoc.querySelector("TriOrb_SICK_SLS_Editor"));
            return { traces: tracesFromPlotData, warning: "", triOrbPresent };
          }

          const polygonTrace = parsePolygonTrace(doc);
          if (polygonTrace.length) {
            const triOrbPresent = Boolean(triOrbDoc.querySelector("TriOrb_SICK_SLS_Editor"));
            return { traces: polygonTrace, warning: "", triOrbPresent };
          }

          return {
            traces: [],
            warning: "Plot data was not found; displaying an empty plot.",
            triOrbPresent: Boolean(triOrbDoc.querySelector("TriOrb_SICK_SLS_Editor")),
          };
        }
        function buildTraceFromPoints(x, y, opts = {}, index = 0) {
          return {
            type: "scatter",
            mode: opts.mode || "lines",
            x,
            y,
            line: {
              color: opts.color || "#1f77b4",
              width: 2,
            },
            name: formatLegendLabel(opts.name || `Trace ${index + 1}`),
            hovertemplate: "<b>%{text}</b><extra></extra>",
            text: opts.name,
            meta: {
              fullLabel: opts.name || `Trace ${index + 1}`,
            },
          };
        }

        function parsePlotDataTraces(doc) {
  const traces = Array.from(
    doc.querySelectorAll(
      "PlotData > Trace, PlotlyData > Trace, PlotlyData > Traces > Trace, TriOrb_SICK_SLS_Editor > PlotlyData > Traces > Trace"
    )
  );
  return traces.map((traceNode, index) => {
            const points = Array.from(traceNode.getElementsByTagName("Point"));
            const x = [];
            const y = [];
            points.forEach((pt) => {
              const xVal = Number(pt.getAttribute("X"));
            const yVal = Number(pt.getAttribute("Y"));
            if (Number.isFinite(xVal) && Number.isFinite(yVal)) {
              x.push(xVal);
              y.push(yVal);
            }
          });

          return buildTraceFromPoints(
            x,
            y,
            {
              name: traceNode.getAttribute("Name") || `Trace ${index + 1}`,
              mode: traceNode.getAttribute("Mode") || "lines+markers",
            },
            index
          );
        });
      }

function parsePolygonTrace(doc) {
  const polygon = doc.querySelector("Polygon");
          if (!polygon) {
            return [];
          }

          const points = Array.from(polygon.getElementsByTagName("Point"));
          const x = [];
          const y = [];
          points.forEach((pt) => {
            const xVal = Number(pt.getAttribute("X"));
            const yVal = Number(pt.getAttribute("Y"));
            if (Number.isFinite(xVal) && Number.isFinite(yVal)) {
              x.push(xVal);
              y.push(yVal);
            }
          });

          const polygonTrace = buildTraceFromPoints(
            x,
            y,
            {
              name: polygon.getAttribute("Type") || "Polygon",
              mode: "lines+markers",
              fill: "toself",
            },
            0
          );

          const traces = [polygonTrace];
          if (originTrace) {
            traces.push(cloneTrace(originTrace));
          }
          return traces;
        }
        function populateFileInfoFromDoc(doc) {
          const fileInfoNode = doc.querySelector("FileInfo");
          if (!fileInfoNode) return;
          const inputs = document.querySelectorAll(".menu-fileinfo-field input");
          inputs.forEach((input) => {
            const targetTag = input.dataset.field || sanitizeTagName(input.id || "Field");
            const element = fileInfoNode.getElementsByTagName(targetTag)[0];
            if (element && typeof element.textContent === "string") {
              input.value = element.textContent.trim();
            }
          });
        }

        function populateScanPlanesFromDoc(doc) {
          const planeNodes = doc.querySelectorAll("Export_ScanPlanes > ScanPlane");
          if (!planeNodes.length) {
            return;
          }
          scanPlanes = Array.from(planeNodes).map((planeNode, planeIndex) => {
            const attributes = {};
            Array.from(planeNode.attributes).forEach((attr) => {
              attributes[attr.name] = attr.value;
            });
            if (!("Index" in attributes)) {
              attributes.Index = String(planeIndex);
            }
            const devices = Array.from(planeNode.querySelectorAll("Devices > Device")).map((deviceNode, deviceIndex) => {
              const deviceAttrs = {};
              Array.from(deviceNode.attributes).forEach((attr) => {
                deviceAttrs[attr.name] = attr.value;
              });
              if (!("Index" in deviceAttrs)) {
                deviceAttrs.Index = String(deviceIndex);
              }
              return { attributes: deviceAttrs };
            });
            return { attributes, devices };
          });
          renderScanPlanes();
        }

        function collectTriOrbShapeDetails(shapeNode) {
          const type = shapeNode.getAttribute("Type") || "Polygon";
          const result = { id: shapeNode.getAttribute("ID") || createShapeId(), name: shapeNode.getAttribute("Name") || "", type };
          if (type === "Polygon") {
            const polygon = shapeNode.querySelector("Polygon");
            if (polygon) {
              result.polygon = {
                Type: polygon.getAttribute("Type") || "CutOut",
                points: Array.from(polygon.getElementsByTagName("Point")).map((pt) => ({
                  X: pt.getAttribute("X") || "0",
                  Y: pt.getAttribute("Y") || "0",
                })),
              };
            }
          } else if (type === "Rectangle") {
            const rectangle = shapeNode.querySelector("Rectangle");
            if (rectangle) {
              result.rectangle = Array.from(rectangle.attributes).reduce((acc, attr) => {
                acc[attr.name] = attr.value;
                return acc;
              }, {});
            }
          } else if (type === "Circle") {
            const circle = shapeNode.querySelector("Circle");
            if (circle) {
              result.circle = Array.from(circle.attributes).reduce((acc, attr) => {
                acc[attr.name] = attr.value;
                return acc;
              }, {});
            }
          }
          return result;
        }

        function populateTriOrbShapesFromDoc(doc) {
          const triOrbNode = doc.querySelector("TriOrb_SICK_SLS_Editor");
          console.log("populateTriOrbShapesFromDoc triOrbNode", triOrbNode);
          if (!triOrbNode) {
            return;
          }
          const shapesParent = triOrbNode.querySelector("Shapes");
          if (!shapesParent) {
            return;
          }
          const nodes = Array.from(shapesParent.querySelectorAll("Shape"));
          console.log(
            "populateTriOrbShapesFromDoc TriOrb node",
            shapesParent.parentElement?.tagName,
            "shapes count",
            nodes.length
          );
          if (!nodes.length) {
            return;
          }
          triorbShapes = nodes.map((shapeNode, index) => {
            const detail = collectTriOrbShapeDetails(shapeNode);
            return {
              id: detail.id,
              name: detail.name || `Shape ${index + 1}`,
              type: detail.type || "Polygon",
              polygon: detail.polygon || createDefaultPolygonDetails(),
              rectangle: detail.rectangle || createDefaultRectangleDetails(),
              circle: detail.circle || createDefaultCircleDetails(),
              visible: true,
            };
          });
          renderTriOrbShapes();
          renderTriOrbShapeCheckboxes();
        }

        function populateFieldsetsFromDoc(doc) {
          const scanPlaneNode = doc.querySelector(
            "Export_FieldsetsAndFields > ScanPlane"
          );
          if (!scanPlaneNode) {
            fieldsets = [createDefaultFieldset(0)];
            fieldsetDevices = [createDefaultFieldsetDevice(0)];
            fieldsetGlobalGeometry = initializeGlobalGeometry({});
            renderFieldsets();
            renderFieldsetDevices();
            renderFieldsetGlobal();
            return;
          }

          const devicesParent = scanPlaneNode.querySelector("Devices");
          if (devicesParent) {
            fieldsetDevices = Array.from(
              devicesParent.querySelectorAll("Device")
            ).map((deviceNode, deviceIndex) => {
              const attrs = {};
              Array.from(deviceNode.attributes).forEach((attr) => {
                attrs[attr.name] = attr.value;
              });
              const scanDevice = findScanPlaneDeviceByTypekey(attrs.Typekey);
              if (scanDevice?.attributes?.DeviceName) {
                attrs.DeviceName = scanDevice.attributes.DeviceName;
              } else if (!("DeviceName" in attrs)) {
                attrs.DeviceName = `Device ${deviceIndex + 1}`;
              }
              return { attributes: attrs };
            });
          } else {
            fieldsetDevices = [];
          }

          const globalNode = scanPlaneNode.querySelector("GlobalGeometry");
          fieldsetGlobalGeometry = globalNode
            ? Array.from(globalNode.attributes).reduce((acc, attr) => {
                acc[attr.name] = attr.value;
                return acc;
              }, {})
            : { UseGlobalGeometry: "false" };

          const fieldsetsParent = scanPlaneNode.querySelector("Fieldsets");
          const fieldsetNodes = fieldsetsParent
            ? fieldsetsParent.querySelectorAll("Fieldset")
            : [];

          if (!fieldsetNodes.length) {
            fieldsets = [createDefaultFieldset(0)];
          } else {
          fieldsets = Array.from(fieldsetNodes).map((fieldsetNode, fieldsetIndex) => {
            const attributes = {};
            Array.from(fieldsetNode.attributes).forEach((attr) => {
              attributes[attr.name] = attr.value;
            });
              if (!("Name" in attributes)) {
                attributes.Name = `Fieldset ${fieldsetIndex + 1}`;
              }

              const fieldNodes = Array.from(
                fieldsetNode.querySelectorAll("Field")
              );

              const fields = fieldNodes.map((fieldNode, fieldIndex) => {
                const fieldAttrs = {};
                Array.from(fieldNode.attributes).forEach((attr) => {
                  fieldAttrs[attr.name] = attr.value;
                });
                if (!("Name" in fieldAttrs)) {
                  fieldAttrs.Name = `Field ${fieldIndex + 1}`;
                }

                const polygonNodes = Array.from(
                  fieldNode.querySelectorAll("Polygon")
                );
                const polygons = polygonNodes.map((polygonNode) => {
                  const polygonAttrs = {};
                  Array.from(polygonNode.attributes).forEach((attr) => {
                    polygonAttrs[attr.name] = attr.value;
                  });
                  const pointNodes = Array.from(polygonNode.querySelectorAll("Point"));
                  const points = pointNodes.map((pointNode) => {
                    const pointAttrs = {};
                    Array.from(pointNode.attributes).forEach((attr) => {
                      pointAttrs[attr.name] = attr.value;
                    });
                    return pointAttrs;
                  });
                  return { attributes: polygonAttrs, points };
                });

              const circleNodes = Array.from(
                fieldNode.querySelectorAll("Circle")
              );
              const circles = circleNodes.map((circleNode) => {
                const circleAttrs = {};
                Array.from(circleNode.attributes).forEach((attr) => {
                  circleAttrs[attr.name] = attr.value;
                });
                return circleAttrs;
              });

              const rectangleNodes = Array.from(
                fieldNode.querySelectorAll("Rectangle")
              );
              const rectangles = rectangleNodes.map((rectangleNode) => {
                const rectangleAttrs = {};
                Array.from(rectangleNode.attributes).forEach((attr) => {
                  rectangleAttrs[attr.name] = attr.value;
                });
                return rectangleAttrs;
              });

              return {
                attributes: fieldAttrs,
                polygons,
                circles,
                rectangles,
              };
            });

              return {
                attributes,
                fields,
                visible: true,
              };
            });
          }

          globalMultipleSampling = deriveInitialMultipleSampling(fieldsets);
          if (globalMultipleSamplingInput) {
            globalMultipleSamplingInput.value = globalMultipleSampling;
          }
          applyGlobalMultipleSampling(globalMultipleSampling, { rerender: false });
          renderFieldsets();
          renderFieldsetDevices();
          renderFieldsetGlobal();
        }

        function convertElementToGenericNode(element) {
          if (!element) {
            return null;
          }
          const attrs = {};
          Array.from(element.attributes || []).forEach((attr) => {
            attrs[attr.name] = attr.value;
          });
          const textContent = Array.from(element.childNodes || [])
            .filter((node) => node.nodeType === Node.TEXT_NODE)
            .map((node) => node.textContent || "")
            .join("")
            .trim();
          const children = Array.from(element.children || [])
            .map((child) => convertElementToGenericNode(child))
            .filter(Boolean);
          return { tag: element.tagName, attributes: attrs, text: textContent, children };
        }

        function serializeStaticInputElement(element) {
          const attrs = {};
          Array.from(element.attributes || []).forEach((attr) => {
            attrs[attr.name] = attr.value;
          });
          const valueKey = resolveStaticInputValueKey(attrs);
          return { attributes: attrs, value_key: valueKey };
        }

        function serializeSpeedActivationElement(element) {
          const attrs = {};
          Array.from(element.attributes || []).forEach((attr) => {
            attrs[attr.name] = attr.value;
          });
          return { attributes: attrs, mode_key: resolveSpeedActivationKey(attrs) };
        }

        function serializeCaseElement(caseElement) {
          const attrs = {};
          Array.from(caseElement.attributes || []).forEach((attr) => {
            attrs[attr.name] = attr.value;
          });
          const entry = { attributes: attrs, static_inputs: [], speed_activation: null, layout: [] };
          Array.from(caseElement.children || []).forEach((child) => {
            if (child.tagName === "StaticInputs") {
              const staticInputs = Array.from(child.querySelectorAll(":scope > StaticInput")).map((staticNode) =>
                serializeStaticInputElement(staticNode)
              );
              entry.static_inputs = staticInputs;
              entry.layout.push({ kind: "static-inputs" });
            } else if (child.tagName === "SpeedActivation") {
              entry.speed_activation = serializeSpeedActivationElement(child);
              entry.layout.push({ kind: "speed-activation" });
            } else {
              entry.layout.push({ kind: "node", node: convertElementToGenericNode(child) });
            }
          });
          return entry;
        }

        function populateCasetablesFromDoc(doc) {
          const casetableNodes = Array.from(
            doc.querySelectorAll("Export_CasetablesAndCases > Casetable")
          );
          let casetableNode =
            casetableNodes.find((node) => node.getAttribute("Index") === "0") ||
            casetableNodes[0] ||
            null;
          if (!casetableNode) {
            casetableAttributes = { Index: "0" };
            casetableConfiguration = createDefaultCasetableConfiguration();
            casetableCases = [createDefaultCasetableCase(0)];
            casetableLayout = normalizeCasetableLayout([]);
            casetableEvals = null;
            casetableFieldsConfiguration = null;
            renderCasetableConfiguration();
            renderCasetableCases();
            return;
          }
          casetableAttributes = Array.from(casetableNode.attributes || []).reduce(
            (acc, attr) => {
              acc[attr.name] = attr.value;
              return acc;
            },
            {}
          );
          const layout = [];
          Array.from(casetableNode.children || []).forEach((child) => {
            if (child.tagName === "Configuration") {
              casetableConfiguration =
                convertElementToGenericNode(child) || createDefaultCasetableConfiguration();
              layout.push({ kind: "configuration" });
            } else if (child.tagName === "Cases") {
              const serializedCases = Array.from(child.querySelectorAll(":scope > Case")).map((caseElement) =>
                serializeCaseElement(caseElement)
              );
              casetableCases = initializeCasetableCases(serializedCases);
              layout.push({ kind: "cases" });
            } else if (child.tagName === "Evals") {
              casetableEvals = convertElementToGenericNode(child);
              layout.push({ kind: "evals" });
            } else if (child.tagName === "FieldsConfiguration") {
              casetableFieldsConfiguration = convertElementToGenericNode(child);
              layout.push({ kind: "fields_configuration" });
            } else {
              layout.push({ kind: "node", node: convertElementToGenericNode(child) });
            }
          });
          casetableLayout = normalizeCasetableLayout(layout);
          if (!layout.some((segment) => segment.kind === "cases")) {
            casetableCases = initializeCasetableCases([]);
          }
          renderCasetableConfiguration();
          renderCasetableCases();
        }

        function findOriginTrace(figure) {
          return figure.data?.find((trace) => {
            const x = trace.x || [];
            const y = trace.y || [];
            return x.length === 1 && y.length === 1 && x[0] === 0 && y[0] === 0;
          });
        }

        function syncPlotSize() {
          if (!plotWrapper) return;
          const width = plotWrapper.clientWidth;
          const computedHeight = Math.max(420, Math.min(900, width * 0.6));
          plotNode.style.height = `${computedHeight}px`;
        }

        if (addScanPlaneBtn) {
          addScanPlaneBtn.addEventListener("click", () => {
            scanPlanes.push(createDefaultScanPlane(scanPlanes.length));
            renderScanPlanes();
          });
        }

        if (scanPlanesContainer) {
          scanPlanesContainer.addEventListener("click", (event) => {
            const addTarget = event.target.closest("[data-action='add-device']");
            if (addTarget) {
              event.preventDefault();
              event.stopPropagation();
              const planeIndex = Number(addTarget.dataset.planeIndex);
              const plane = scanPlanes[planeIndex];
              if (plane) {
                const newDevice = createDefaultDevice(plane.devices.length);
                plane.devices.push(newDevice);
                renderScanPlanes();
              }
              return;
            }

            const removeDeviceTarget = event.target.closest("[data-action='remove-device']");
            if (removeDeviceTarget) {
              event.preventDefault();
              event.stopPropagation();
              const planeIndex = Number(removeDeviceTarget.dataset.planeIndex);
              const deviceIndex = Number(removeDeviceTarget.dataset.deviceIndex);
              const plane = scanPlanes[planeIndex];
              if (plane && plane.devices) {
                plane.devices.splice(deviceIndex, 1);
                renderScanPlanes();
              }
              return;
            }

            const removePlaneTarget = event.target.closest("[data-action='remove-scanplane']");
            if (removePlaneTarget) {
              event.preventDefault();
              event.stopPropagation();
              const planeIndex = Number(removePlaneTarget.dataset.planeIndex);
              scanPlanes.splice(planeIndex, 1);
              renderScanPlanes();
            }
          });

          scanPlanesContainer.addEventListener("input", (event) => {
            const target = event.target;
            if (target.classList.contains("scanplane-attr")) {
              const planeIndex = Number(target.dataset.planeIndex);
              const field = target.dataset.field;
              updateScanPlaneAttribute(planeIndex, field, target.value);
            } else if (target.classList.contains("device-attr")) {
              const planeIndex = Number(target.dataset.planeIndex);
              const deviceIndex = Number(target.dataset.deviceIndex);
              const field = target.dataset.field;
              updateDeviceAttribute(planeIndex, deviceIndex, field, target.value);
            }
          });
        }

        if (addFieldsetBtn) {
          addFieldsetBtn.addEventListener("click", () => {
            fieldsets.push(createDefaultFieldset(fieldsets.length));
            applyGlobalMultipleSampling(globalMultipleSampling, { rerender: false });
            renderFieldsets();
          });
        }

        if (globalMultipleSamplingInput) {
          globalMultipleSamplingInput.addEventListener("input", (event) => {
            let value = parseInt(event.target.value, 10);
            if (Number.isNaN(value)) {
              value = 2;
            }
            value = Math.min(16, Math.max(2, value));
            event.target.value = value;
            applyGlobalMultipleSampling(String(value));
            handleTriOrbFieldChange();
          });
        }

        function updateGlobalFieldAttributes() {
          fieldsets.forEach((fieldset) => {
            (fieldset.fields || []).forEach((field) => {
              field.attributes = field.attributes || {};
              field.attributes.MultipleSampling = String(globalMultipleSampling);
              field.attributes.Resolution = String(globalResolution);
              field.attributes.TolerancePositive = String(globalTolerancePositive);
              field.attributes.ToleranceNegative = String(globalToleranceNegative);
            });
          });
        }

        function handleTriOrbFieldChange() {
          updateGlobalFieldAttributes();
          renderFieldsets();
          renderFigure();
        }

        if (globalResolutionInput) {
          globalResolutionInput.addEventListener("input", (event) => {
            const value = parseNumeric(event.target.value, globalResolution);
            globalResolution = Number.isFinite(value) ? value : globalResolution;
            event.target.value = globalResolution;
            handleTriOrbFieldChange();
          });
        }

        if (globalTolerancePositiveInput) {
          globalTolerancePositiveInput.addEventListener("input", (event) => {
            const value = parseNumeric(event.target.value, globalTolerancePositive);
            globalTolerancePositive = Number.isFinite(value) ? value : globalTolerancePositive;
            event.target.value = globalTolerancePositive;
            handleTriOrbFieldChange();
          });
        }

        if (globalToleranceNegativeInput) {
          globalToleranceNegativeInput.addEventListener("input", (event) => {
            const value = parseNumeric(event.target.value, globalToleranceNegative);
            globalToleranceNegative = Number.isFinite(value) ? value : globalToleranceNegative;
            event.target.value = globalToleranceNegative;
            handleTriOrbFieldChange();
          });
        }

        if (fieldOfViewInput) {
          fieldOfViewInput.addEventListener("input", (event) => {
            const nextValue = parseNumeric(event.target.value, fieldOfViewDegrees);
            if (!Number.isFinite(nextValue)) {
              event.target.value = fieldOfViewDegrees;
              return;
            }
            fieldOfViewDegrees = nextValue;
            event.target.value = fieldOfViewDegrees;
            renderFigure();
          });
        }

        if (addFieldsetDeviceBtn) {
          addFieldsetDeviceBtn.addEventListener("click", () => {
            fieldsetDevices.push(createDefaultFieldsetDevice(fieldsetDevices.length));
            renderFieldsetDevices();
            renderFigure();
          });
        }

        if (fieldsetDevicesContainer) {
          fieldsetDevicesContainer.addEventListener("click", (event) => {
            const removeDevice = event.target.closest("[data-action='remove-fieldset-device']");
            if (removeDevice) {
              event.preventDefault();
              event.stopPropagation();
              const deviceIndex = Number(removeDevice.dataset.deviceIndex);
              fieldsetDevices.splice(deviceIndex, 1);
              renderFieldsetDevices();
              renderFigure();
            }
          });

          const handleDeviceFieldInput = (event) => {
            const target = event.target;
            if (target.classList.contains("fieldset-device-name")) {
              const deviceIndex = Number(target.dataset.deviceIndex);
              const selectedName = target.value;
              const device = fieldsetDevices[deviceIndex];
              if (device) {
                applyScanPlaneDeviceAttributes(device, { deviceName: selectedName });
                renderFieldsetDevices();
                renderFigure();
              }
            } else if (target.classList.contains("fieldset-device-attr")) {
              const deviceIndex = Number(target.dataset.deviceIndex);
              const field = target.dataset.field;
              updateFieldsetDeviceAttribute(deviceIndex, field, target.value);
            }
          };

          fieldsetDevicesContainer.addEventListener("input", handleDeviceFieldInput);
          fieldsetDevicesContainer.addEventListener("change", handleDeviceFieldInput);
        }

        if (fieldsetGlobalContainer) {
          fieldsetGlobalContainer.addEventListener("input", (event) => {
            const target = event.target;
            if (target.classList.contains("fieldset-global-attr")) {
              const field = target.dataset.field;
              updateGlobalGeometryAttribute(field, target.value);
            }
          });
        }

        function renderCasetableConfiguration() {
          if (!casetableConfigurationContainer) {
            return;
          }
          if (!casetableConfiguration) {
            casetableConfigurationContainer.innerHTML =
              '<p class="casetable-help-text">No configuration nodes.</p>';
            return;
          }
          casetableConfigurationContainer.innerHTML = renderCasetableConfigNode(
            casetableConfiguration,
            "root"
          );
        }

        function renderCasetableConfigNode(node, path) {
          if (!node) {
            return "";
          }
          const attributes = Object.entries(node.attributes || {});
          const attrHtml = attributes.length
            ? `<div class="casetable-config-attrs">
                ${attributes
                  .map(
                    ([key, value]) => `
                  <div class="casetable-case-field">
                    <label>${escapeHtml(key)}</label>
                    <input
                      type="text"
                      class="casetable-config-input"
                      data-config-path="${path}"
                      data-config-field="${escapeHtml(key)}"
                      value="${escapeHtml(value ?? "")}"
                    />
                  </div>`
                  )
                  .join("")}
              </div>`
            : '<p class="casetable-help-text">No attributes.</p>';
          const textField =
            typeof node.text === "string" && node.text.length
              ? `<div class="casetable-config-attrs">
                  <div class="casetable-case-field">
                    <label>Text</label>
                    <textarea
                      class="casetable-config-text"
                      data-config-path="${path}"
                      data-config-text="true"
                    >${escapeHtml(node.text)}</textarea>
                  </div>
                </div>`
              : "";
          const childrenHtml = Array.isArray(node.children)
            ? node.children
                .map((child, childIndex) =>
                  renderCasetableConfigNode(child, `${path}.${childIndex}`)
                )
                .join("")
            : "";
          return `
            <div class="casetable-config-node" data-config-node="${path}">
              <details open>
                <summary>${escapeHtml(node.tag || "Node")}</summary>
                ${attrHtml}
                ${textField}
                ${childrenHtml ? `<div class="casetable-config-children">${childrenHtml}</div>` : ""}
              </details>
            </div>`;
        }

        function renderCasetableCases() {
          if (casetableCaseCountLabel) {
            casetableCaseCountLabel.textContent = `${casetableCases.length} / ${casetableCasesLimit}`;
          }
          if (!casetableCasesContainer) {
            return;
          }
          if (!casetableCases.length) {
            casetableCasesContainer.innerHTML =
              '<p class="casetable-help-text">No cases defined.</p>';
          } else {
            casetableCasesContainer.innerHTML = casetableCases
              .map((caseData, caseIndex) => renderCasetableCase(caseData, caseIndex))
              .join("");
          }
          if (addCasetableCaseBtn) {
            addCasetableCaseBtn.disabled = casetableCases.length >= casetableCasesLimit;
          }
        }

        function renderCasetableCase(caseData, caseIndex) {
          const attributes = Object.entries(caseData.attributes || {}).filter(
            ([key]) => key !== "Id" && key !== "DisplayOrder"
          );
          const attrFields = attributes.length
            ? `<div class="casetable-case-grid">
                ${attributes
                  .map(
                    ([key, value]) => `
                  <div class="casetable-case-field">
                    <label>${escapeHtml(key)}</label>
                    <input
                      type="text"
                      class="casetable-case-input"
                      data-case-index="${caseIndex}"
                      data-case-field="${escapeHtml(key)}"
                      value="${escapeHtml(value ?? "")}"
                    />
                  </div>`
                  )
                  .join("")}
              </div>`
            : '<p class="casetable-help-text">No editable attributes.</p>';
          const staticInputsSection = caseData.staticInputs?.length
            ? `<div class="casetable-static-inputs">
                ${caseData.staticInputs
                  .map((input, staticIndex) =>
                    renderStaticInputToggle(caseIndex, staticIndex, input)
                  )
                  .join("")}
              </div>`
            : '<p class="casetable-help-text">No static inputs defined.</p>';
          const speedActivationSection = caseData.speedActivation
            ? `<div class="casetable-speed-activation">
                <label>SpeedActivation</label>
                <select class="casetable-speed-select" data-case-index="${caseIndex}">
                  ${["Off", "SpeedRange"]
                    .map((option) => {
                      const currentValue = String(
                        caseData.speedActivation.attributes?.[
                          caseData.speedActivation.modeKey
                        ] ?? ""
                      ).toLowerCase();
                      const isSelected = currentValue === option.toLowerCase();
                      return `<option value="${option}"${
                        isSelected ? " selected" : ""
                      }>${option}</option>`;
                    })
                    .join("")}
                </select>
              </div>`
            : "";
          const hasReadonlyNodes = Array.isArray(caseData.layout)
            ? caseData.layout.some((segment) => segment.kind === "node")
            : false;
          const summaryName = caseData.attributes?.Name || buildCaseName(caseIndex);
          return `
            <div class="casetable-case-card" data-case-index="${caseIndex}">
              <details open>
                <summary>
                  <span>Case #${caseIndex + 1}</span>
                  <span class="casetable-case-summary">${escapeHtml(summaryName)}</span>
                  <button
                    type="button"
                    class="inline-btn inline-danger"
                    data-action="remove-case"
                    data-case-index="${caseIndex}"
                  >
                    Remove
                  </button>
                </summary>
                <div class="casetable-case-body">
                  ${attrFields}
                  ${staticInputsSection}
                  ${speedActivationSection || ""}
                  ${
                    hasReadonlyNodes
                      ? '<p class="casetable-readonly-note">Additional nodes will be preserved when saving.</p>'
                      : ""
                  }
                </div>
              </details>
            </div>`;
        }

        function renderStaticInputToggle(caseIndex, staticIndex, input) {
          const attributes = input?.attributes || {};
          const label = attributes.Name || `StaticInput ${staticIndex + 1}`;
          const key = input?.valueKey || resolveStaticInputValueKey(attributes);
          const currentValue = String(attributes[key] || "Low").toLowerCase();
          const options = ["Low", "High"];
          const buttons = options
            .map((option) => {
              const isActive = currentValue === option.toLowerCase();
              return `<button
                type="button"
                class="toggle-option${isActive ? " is-active" : ""}"
                data-action="toggle-static-input"
                data-case-index="${caseIndex}"
                data-static-index="${staticIndex}"
                data-static-value="${option}"
              >${option}</button>`;
            })
            .join("");
          return `
            <div class="casetable-static-group">
              <span class="casetable-static-label">${escapeHtml(label)}</span>
              <div class="toggle-group">${buttons}</div>
            </div>`;
        }

        function renderFieldsetCheckboxes() {
          if (!fieldsetCheckboxes) {
            return;
          }
          if (!fieldsets.length) {
            fieldsetCheckboxes.innerHTML = '<p class="toggle-pill-empty">No fieldsets available.</p>';
            return;
          }
          fieldsetCheckboxes.innerHTML = fieldsets
            .map((fieldset, index) => {
              const isVisible = fieldset.visible !== false;
              fieldset.visible = isVisible;
              return `
              <button
                type="button"
                class="toggle-pill-btn${isVisible ? " active" : ""}"
                data-fieldset-index="${index}"
                aria-pressed="${isVisible}"
              >
                ${escapeHtml(fieldset.attributes?.Name || `Fieldset ${index + 1}`)}
              </button>`;
            })
            .join("");
        }

        if (fieldsetCheckboxes) {
          fieldsetCheckboxes.addEventListener("click", (event) => {
            const button = event.target.closest(".toggle-pill-btn");
            if (!button || !button.dataset.fieldsetIndex) {
              return;
            }
            event.preventDefault();
            const index = Number(button.dataset.fieldsetIndex);
            const nextState = !button.classList.contains("active");
            button.classList.toggle("active", nextState);
            button.setAttribute("aria-pressed", String(nextState));
            if (fieldsets[index]) {
              fieldsets[index].visible = nextState;
              setStatus(
                `Fieldset ${fieldsets[index].attributes?.Name || index + 1} ${
                  nextState ? "checked" : "unchecked"
                }`,
                nextState ? "ok" : "warning"
              );
              renderFigure();
            }
          });
        }

        if (checkAllBtn) {
          checkAllBtn.addEventListener("click", () => {
            toggleAllFieldsetCheckboxes(true);
          });
        }

        if (uncheckAllBtn) {
          uncheckAllBtn.addEventListener("click", () => {
            toggleAllFieldsetCheckboxes(false);
          });
        }

        if (triorbShapeCheckboxes) {
          triorbShapeCheckboxes.addEventListener("click", (event) => {
            const button = event.target.closest(".toggle-pill-btn");
            if (!button || !button.dataset.shapeIndex) {
              return;
            }
            event.preventDefault();
            const index = Number(button.dataset.shapeIndex);
            const shape = triorbShapes[index];
            if (!shape) {
              return;
            }
            const nextState = !button.classList.contains("active");
            button.classList.toggle("active", nextState);
            button.setAttribute("aria-pressed", String(nextState));
            shape.visible = nextState;
            renderFigure();
          });
        }

        if (triorbShapeCheckAllBtn) {
          triorbShapeCheckAllBtn.addEventListener("click", () => {
            setTriOrbShapeVisibility(true);
          });
        }

        if (triorbShapeUncheckAllBtn) {
          triorbShapeUncheckAllBtn.addEventListener("click", () => {
            setTriOrbShapeVisibility(false);
          });
        }

        if (casetableConfigurationContainer) {
          casetableConfigurationContainer.addEventListener("input", (event) => {
            const target = event.target;
            if (target.classList.contains("casetable-config-input")) {
              const path = target.dataset.configPath;
              const field = target.dataset.configField;
              updateCasetableConfigAttribute(path, field, target.value);
            } else if (target.classList.contains("casetable-config-text")) {
              const path = target.dataset.configPath;
              updateCasetableConfigText(path, target.value);
            }
          });
        }

        if (casetableCasesContainer) {
          casetableCasesContainer.addEventListener("input", (event) => {
            const target = event.target;
            if (target.classList.contains("casetable-case-input")) {
              const caseIndex = Number(target.dataset.caseIndex);
              const field = target.dataset.caseField;
              updateCaseAttribute(caseIndex, field, target.value);
            } else if (target.classList.contains("casetable-speed-select")) {
              const caseIndex = Number(target.dataset.caseIndex);
              updateSpeedActivationValue(caseIndex, target.value);
            }
          });

          casetableCasesContainer.addEventListener("click", (event) => {
            const removeBtn = event.target.closest("[data-action='remove-case']");
            if (removeBtn) {
              event.preventDefault();
              const caseIndex = Number(removeBtn.dataset.caseIndex);
              casetableCases.splice(caseIndex, 1);
              renderCasetableCases();
              return;
            }
            const toggleBtn = event.target.closest("[data-action='toggle-static-input']");
            if (toggleBtn) {
              event.preventDefault();
              const caseIndex = Number(toggleBtn.dataset.caseIndex);
              const staticIndex = Number(toggleBtn.dataset.staticIndex);
              const value = toggleBtn.dataset.staticValue;
              updateStaticInputValue(caseIndex, staticIndex, value);
              renderCasetableCases();
            }
          });
        }

        if (addCasetableCaseBtn) {
          addCasetableCaseBtn.addEventListener("click", () => {
            if (casetableCases.length >= casetableCasesLimit) {
              setStatus(`Case limit of ${casetableCasesLimit} reached.`, "warning");
              return;
            }
            casetableCases.push(createDefaultCasetableCase(casetableCases.length));
            renderCasetableCases();
          });
        }

        function addFieldShapeRef(fieldsetIndex, fieldIndex, shapeId) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field || !shapeId) {
            return;
          }
          field.shapeRefs = field.shapeRefs || [];
          if (field.shapeRefs.some((ref) => ref.shapeId === shapeId)) {
            return;
          }
          field.shapeRefs.push({ shapeId });
          renderFieldsets();
        }

        function removeFieldShapeRef(fieldsetIndex, fieldIndex, shapeIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field || !Array.isArray(field.shapeRefs)) {
            return;
          }
          field.shapeRefs.splice(shapeIndex, 1);
          renderFieldsets();
        }

        function openTriOrbShapeEditor(shapeId) {
          const shapeIndex = triorbShapes.findIndex((shape) => shape.id === shapeId);
          if (shapeIndex < 0) {
            return;
          }
          const shape = triorbShapes[shapeIndex];
          renderShapeModal({
            kind: (shape.type || "polygon").toLowerCase(),
            shapeIndex,
            shapeType: shape.type,
            isTriOrbShape: true,
          });
        }

        const handleFieldsetInput = (event) => {
          const target = event.target;
          if (!target) return;
          if (target.classList.contains("fieldset-attr")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const field = target.dataset.field;
            updateFieldsetAttribute(fieldsetIndex, field, target.value);
          } else if (target.classList.contains("field-attr")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const field = target.dataset.field;
            updateFieldAttribute(fieldsetIndex, fieldIndex, field, target.value);
          } else if (target.classList.contains("polygon-type")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const polygonIndex = Number(target.dataset.polygonIndex);
            updatePolygonAttribute(fieldsetIndex, fieldIndex, polygonIndex, "Type", target.value);
          } else if (target.classList.contains("polygon-point")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const polygonIndex = Number(target.dataset.polygonIndex);
            const pointIndex = Number(target.dataset.pointIndex);
            const axis = target.dataset.axis === "Y" ? "Y" : "X";
            updatePolygonPoint(fieldsetIndex, fieldIndex, polygonIndex, pointIndex, axis, target.value);
          } else if (target.classList.contains("rectangle-type")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const rectangleIndex = Number(target.dataset.rectangleIndex);
            updateRectangleAttribute(fieldsetIndex, fieldIndex, rectangleIndex, "Type", target.value);
          } else if (target.classList.contains("rectangle-attr")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const rectangleIndex = Number(target.dataset.rectangleIndex);
            const field = target.dataset.field;
            updateRectangleAttribute(fieldsetIndex, fieldIndex, rectangleIndex, field, target.value);
          } else if (target.classList.contains("circle-type")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const circleIndex = Number(target.dataset.circleIndex);
            updateCircleAttribute(fieldsetIndex, fieldIndex, circleIndex, "Type", target.value);
          } else if (target.classList.contains("circle-attr")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const circleIndex = Number(target.dataset.circleIndex);
            const field = target.dataset.field;
            updateCircleAttribute(fieldsetIndex, fieldIndex, circleIndex, field, target.value);
          }
          };

        if (fieldsetsContainer) {
          fieldsetsContainer.addEventListener("click", (event) => {
            const actionTarget = event.target.closest("[data-action]");
            if (!actionTarget) {
              return;
            }
            event.preventDefault();
            event.stopPropagation();
            const action = actionTarget.dataset.action;
            switch (action) {
              case "remove-fieldset": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                fieldsets.splice(fieldsetIndex, 1);
                renderFieldsets();
                break;
              }
              case "add-field": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldset = fieldsets[fieldsetIndex];
                if (fieldset) {
                  fieldset.fields = fieldset.fields || [];
                  fieldset.fields.push(createDefaultField(fieldset.fields.length));
                  renderFieldsets();
                }
                break;
              }
              case "remove-field": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                const fieldset = fieldsets[fieldsetIndex];
                if (fieldset && fieldset.fields) {
                  fieldset.fields.splice(fieldIndex, 1);
                  renderFieldsets();
                }
                break;
              }
              case "add-field-shape": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                const select = actionTarget
                  .closest(".shape-controls")
                  ?.querySelector(".field-shape-selector");
                const shapeId = select?.value;
                addFieldShapeRef(fieldsetIndex, fieldIndex, shapeId);
                break;
              }
              case "remove-field-shape": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                const shapeIndex = Number(actionTarget.dataset.shapeIndex);
                removeFieldShapeRef(fieldsetIndex, fieldIndex, shapeIndex);
                break;
              }
              case "edit-field-shape": {
                openTriOrbShapeEditor(actionTarget.dataset.shapeId);
                break;
              }
              default:
                break;
            }
          });

          fieldsetsContainer.addEventListener("input", (event) => {
            handleFieldsetInput(event);
          });
          fieldsetsContainer.addEventListener("change", (event) => {
            handleFieldsetInput(event);
          });
        }

        let triOrbSpinnerTimer = null;
        let triOrbSpinnerStep = null;

        if (triorbShapesContainer) {
          triorbShapesContainer.addEventListener("pointerdown", (event) => {
            const target = event.target;
            if (
              target instanceof HTMLInputElement &&
              target.type === "number" &&
              target.closest(".triorb-shape-card")
            ) {
              const rect = target.getBoundingClientRect();
              const isUp = event.clientY < rect.top + rect.height / 2;
              const stepFn = () => {
                if (isUp) {
                  target.stepUp();
                } else {
                  target.stepDown();
                }
                handleTriOrbShapeInput({ target });
              };
              stepFn();
              triOrbSpinnerStep = stepFn;
              triOrbSpinnerTimer = setInterval(stepFn, 140);
            }
          });
          document.addEventListener("pointerup", () => {
            if (triOrbSpinnerTimer) {
              clearInterval(triOrbSpinnerTimer);
              triOrbSpinnerTimer = null;
              triOrbSpinnerStep = null;
            }
          });
          triorbShapesContainer.addEventListener("input", (event) => {
            handleTriOrbShapeInput(event);
          });
          triorbShapesContainer.addEventListener("change", (event) => {
            handleTriOrbShapeInput(event);
          });
          triorbShapesContainer.addEventListener("click", (event) => {
            if (!event.target) return;
            const action = event.target.dataset.action;
            if (action === "remove-triorb-shape") {
              const index = Number(event.target.dataset.shapeIndex);
              removeTriOrbShape(index);
            }
          });
        }

        if (addTriOrbShapeBtn) {
          addTriOrbShapeBtn.addEventListener("click", () => {
            triorbShapes.push(createDefaultTriOrbShape(triorbShapes.length));
            renderTriOrbShapes();
            renderTriOrbShapeCheckboxes();
            renderFieldsets();
          });
        }

        function toggleAllFieldsetCheckboxes(checked) {
          fieldsets.forEach((fieldset) => {
            fieldset.visible = checked;
          });
          renderFieldsetCheckboxes();
          setStatus(
            checked ? "All fieldsets checked." : "All fieldsets unchecked.",
            checked ? "ok" : "warning"
          );
          renderFigure();
        }

        function renderTriOrbShapeCheckboxes() {
          if (!triorbShapeCheckboxes) {
            return;
          }
          if (!triorbShapes.length) {
            triorbShapeCheckboxes.innerHTML = '<p class="toggle-pill-empty">No shapes available.</p>';
            return;
          }
          triorbShapeCheckboxes.innerHTML = triorbShapes
            .map((shape, index) => {
              const isVisible = shape.visible !== false;
              shape.visible = isVisible;
              return `
                <button
                  type="button"
                  class="toggle-pill-btn${isVisible ? " active" : ""}"
                  data-shape-index="${index}"
                  aria-pressed="${isVisible}"
                >
                  ${escapeHtml(shape.name || `Shape ${index + 1}`)}
                </button>`;
            })
            .join("");
        }

        function setTriOrbShapeVisibility(visible) {
          triorbShapes.forEach((shape) => {
            shape.visible = visible;
          });
          renderTriOrbShapeCheckboxes();
          renderFigure();
        }

        function removeTriOrbShape(shapeIndex) {
          if (!Number.isFinite(shapeIndex) || shapeIndex < 0 || shapeIndex >= triorbShapes.length) {
            return;
          }
          const removedShape = triorbShapes[shapeIndex];
          triorbShapes.splice(shapeIndex, 1);
          fieldsets.forEach((fieldset) => {
            (fieldset.fields || []).forEach((field) => {
              if (Array.isArray(field.shapeRefs)) {
                field.shapeRefs = field.shapeRefs.filter(
                  (ref) => ref.shapeId !== removedShape.id
                );
              }
            });
          });
          renderTriOrbShapes();
          renderTriOrbShapeCheckboxes();
          renderFieldsets();
          renderFigure();
        }

        if (saveTriOrbBtn) {
          saveTriOrbBtn.addEventListener("click", () => {
            const xml = buildTriOrbXml();
            downloadXml(xml);
            setStatus("TriOrb XML downloaded.");
          });
        }
        if (saveSickBtn) {
          saveSickBtn.addEventListener("click", () => {
            if (!fieldsetDevices.length) {
              const xml = buildLegacyXml();
              downloadXml(xml, `sick_${Date.now()}.sgexml`);
              setStatus("SICK XML downloaded (no devices).");
              return;
            }
            fieldsetDevices.forEach((device, index) => {
              const scanDevice =
                findScanPlaneDeviceByName(device.attributes?.DeviceName) ||
                findScanPlaneDeviceByTypekey(device.attributes?.Typekey);
              const scanAttrs = {
                ...(scanDevice?.attributes || device.attributes || {}),
              };
              if (!scanAttrs.DeviceName && device.attributes?.DeviceName) {
                scanAttrs.DeviceName = device.attributes.DeviceName;
              }
              const xmlLines = buildBaseSdImportExportLines({
                scanDeviceAttrs: scanAttrs,
                fieldsetDeviceAttrs: device.attributes,
              });
              const xml = xmlLines.join("\n");
              const prefix = formatDeviceFilePrefix(device.attributes, index);
              downloadXml(xml, `${prefix}_${Date.now()}.sgexml`);
            });
            setStatus(`SICK XML downloaded for ${fieldsetDevices.length} device(s).`);
          });
        }
        if (newPlotBtn) {
          newPlotBtn.addEventListener("click", () => {
            fieldsets = [];
            triorbShapes = [];
            createShapePreview = null;
            createShapeDraftId = null;
            renderFieldsets();
            renderTriOrbShapes();
            renderTriOrbShapeCheckboxes();
            renderFieldsetCheckboxes();
            renderFieldsetDevices();
            renderFieldsetGlobal();
            fieldOfViewDegrees = parseNumeric(fieldOfViewInput?.value, 270);
            console.debug("New canvas state", {
              fieldsetDevices,
              fieldOfViewDegrees,
            });
            renderFigure();
            setStatus("New canvas ready.");
          });
        }
        const overlayShapeBtn = document.getElementById("btn-add-shape-overlay");
        const overlayFieldBtn = document.getElementById("btn-add-field-overlay");
        let createShapeModalOffsetX = 0;
        let createShapeModalOffsetY = 0;
        let createShapeDragStartX = 0;
        let createShapeDragStartY = 0;
        let isCreateShapeDragging = false;
        let isCreateShapeResizing = false;
        let createShapeInitialWidth = 0;
        let createShapeInitialHeight = 0;
        let createShapeLastDx = 0;
        let createShapeLastDy = 0;
        function ensureCreateShapePosition() {
          if (createShapeModalWindow) {
            createShapeModalWindow.style.transform = `translate(${createShapeModalOffsetX}px, ${createShapeModalOffsetY}px)`;
          }
        }
        function resetCreateShapeForm() {
          if (!createShapeNameInput) return;
          createShapeNameInput.value = "";
          if (createShapeFieldtypeSelect) {
            createShapeFieldtypeSelect.value = "ProtectiveSafeBlanking";
          }
          if (createShapeKindSelect) {
            createShapeKindSelect.value = "Field";
          }
          if (createShapeTypeSelect) {
            createShapeTypeSelect.value = "Polygon";
          }
          if (createShapePointsInput) {
            createShapePointsInput.value = "(0,0),(100,0),(100,100)";
          }
          const rectDefaults = {
            originx: 0,
            originy: 0,
            width: 100,
            height: 100,
            rotation: 0,
          };
          Object.entries(rectDefaults).forEach(([key, val]) => {
            const input = document.getElementById(`create-rect-${key}`);
            if (input) input.value = val;
          });
          const circleDefaults = {
            centerx: 0,
            centery: 0,
            radius: 100,
          };
          Object.entries(circleDefaults).forEach(([key, val]) => {
            const input = document.getElementById(`create-circle-${key}`);
            if (input) input.value = val;
          });
          updateCreateShapeDimensionVisibility();
        }

        function updateCreateShapeDimensionVisibility() {
          if (!createShapeTypeSelect) return;
          const type = createShapeTypeSelect.value;
          const isPolygon = type === "Polygon";
          const isRectangle = type === "Rectangle";
          const isCircle = type === "Circle";
          if (createShapePolygonGroup) {
            createShapePolygonGroup.classList.toggle("active", isPolygon);
          }
          if (createShapeRectFields) {
            createShapeRectFields.classList.toggle("active", isRectangle);
          }
          if (createShapeCircleFields) {
            createShapeCircleFields.classList.toggle("active", isCircle);
          }
        }

        function getCreateShapeSelectedFieldsets() {
          if (!createShapeFieldsetList) {
            return [];
          }
          return Array.from(
            createShapeFieldsetList.querySelectorAll(".toggle-pill-btn.active")
          )
            .map((button) => Number(button.dataset.createFieldsetIndex))
            .filter((index) => Number.isFinite(index) && index >= 0);
        }

        function readCreateShapeFormShape() {
          if (!createShapeDraftId) {
            createShapeDraftId = createShapeId();
          }
          const geometryType = createShapeTypeSelect?.value || "Polygon";
          const fieldtypeValue = createShapeFieldtypeSelect?.value || "ProtectiveSafeBlanking";
          const kindValue = createShapeKindSelect?.value || "Field";
          const rawName = (createShapeNameInput?.value || "").trim();
          const polygonPoints = parsePolygonPoints(createShapePointsInput?.value || "");
          const rectangle = {
            Type: kindValue,
            OriginX: String(createRectOriginXInput?.value ?? "0"),
            OriginY: String(createRectOriginYInput?.value ?? "0"),
            Width: String(createRectWidthInput?.value ?? "0"),
            Height: String(createRectHeightInput?.value ?? "0"),
            Rotation: String(createRectRotationInput?.value ?? "0"),
          };
          const circle = {
            Type: kindValue,
            CenterX: String(createCircleCenterXInput?.value ?? "0"),
            CenterY: String(createCircleCenterYInput?.value ?? "0"),
            Radius: String(createCircleRadiusInput?.value ?? "0"),
          };
          const polygon = {
            Type: kindValue,
            points: polygonPoints,
          };
          return {
            id: createShapeDraftId,
            name: rawName || `Shape ${triorbShapes.length + 1}`,
            type: geometryType,
            fieldtype: fieldtypeValue,
            kind: kindValue,
            polygon,
            rectangle,
            circle,
            visible: true,
          };
        }

        function validateCreateShapeDraft(shape, { strict = false } = {}) {
          if (!shape) {
            return { ok: false, message: "Shape definition is missing." };
          }
          if (shape.type === "Polygon") {
            const points = Array.isArray(shape.polygon?.points) ? shape.polygon.points : [];
            const minPoints = strict ? 3 : 2;
            if (points.length < minPoints) {
              return {
                ok: false,
                message: strict
                  ? "Polygon には 3 点以上が必要です。"
                  : "Polygon を描画するには 2 点以上が必要です。",
              };
            }
          } else if (shape.type === "Rectangle") {
            const width = parseNumeric(shape.rectangle?.Width, NaN);
            const height = parseNumeric(shape.rectangle?.Height, NaN);
            if (!Number.isFinite(width) || !Number.isFinite(height)) {
              return { ok: false, message: "Rectangle の幅・高さが正しくありません。" };
            }
            if (width === 0 || height === 0) {
              return { ok: false, message: "Rectangle の幅と高さは 0 ではいけません。" };
            }
          } else if (shape.type === "Circle") {
            const radius = parseNumeric(shape.circle?.Radius, NaN);
            if (!Number.isFinite(radius) || radius <= 0) {
              return { ok: false, message: "Circle の半径を正しく入力してください。" };
            }
          }
          return { ok: true };
        }

        function updateCreateShapePreview() {
          const shape = readCreateShapeFormShape();
          const validation = validateCreateShapeDraft(shape, { strict: false });
          createShapePreview = validation.ok ? shape : null;
          renderFigure();
        }

        function clearCreateShapePreview() {
          if (createShapePreview) {
            createShapePreview = null;
            renderFigure();
          }
        }

        function handleCreateShapeFormInput(event) {
          if (!createShapeModal?.classList.contains("active")) {
            return;
          }
          if (!event || !(event.target instanceof HTMLElement)) {
            return;
          }
          updateCreateShapePreview();
        }

        function attachShapeToFieldsets(shapeId, fieldsetIndexes) {
          let attachedCount = 0;
          fieldsetIndexes.forEach((fieldsetIndex) => {
            const fieldset = fieldsets[fieldsetIndex];
            if (!fieldset || !Array.isArray(fieldset.fields)) {
              return;
            }
            fieldset.fields.forEach((field) => {
              field.shapeRefs = field.shapeRefs || [];
              if (!field.shapeRefs.some((ref) => ref.shapeId === shapeId)) {
                field.shapeRefs.push({ shapeId });
                attachedCount += 1;
              }
            });
          });
          return attachedCount;
        }

        function renderCreateShapeFieldsetsList() {
          if (!createShapeFieldsetList) return;
          if (!fieldsets.length) {
            createShapeFieldsetList.innerHTML = "<p>No fieldsets available.</p>";
            return;
          }
          createShapeFieldsetList.innerHTML = fieldsets
            .map((fieldset, index) => {
              const name = escapeHtml(fieldset.attributes?.Name || `Fieldset ${index + 1}`);
              return `
              <button
                type="button"
                class="toggle-pill-btn"
                data-create-fieldset-index="${index}"
                aria-pressed="false"
              >
                ${name}
              </button>`;
            })
            .join("");
        }

        function openCreateShapeModal() {
          resetCreateShapeForm();
          renderCreateShapeFieldsetsList();
          createShapeDraftId = createShapeId();
          updateCreateShapeDimensionVisibility();
          updateCreateShapePreview();
          createShapeModalOffsetX = 0;
          createShapeModalOffsetY = 0;
          ensureCreateShapePosition();
          createShapeModal?.classList.add("active");
          createShapeModal?.setAttribute("aria-hidden", "false");
        }

        function closeCreateShapeModal() {
          clearCreateShapePreview();
          createShapeDraftId = null;
          createShapeModal?.classList.remove("active");
          createShapeModal?.setAttribute("aria-hidden", "true");
        }

        if (overlayShapeBtn) {
          overlayShapeBtn.addEventListener("click", openCreateShapeModal);
        }
        if (overlayFieldBtn) {
          overlayFieldBtn.addEventListener("click", () => {
            console.debug("Add Field button clicked; awaiting implementation.");
          });
        }
        if (createShapeTypeSelect) {
          createShapeTypeSelect.addEventListener("change", () => {
            updateCreateShapeDimensionVisibility();
            updateCreateShapePreview();
          });
          updateCreateShapeDimensionVisibility();
        }
        if (createShapeModalClose) {
          createShapeModalClose.addEventListener("click", closeCreateShapeModal);
        }
        if (createShapeModalCancel) {
          createShapeModalCancel.addEventListener("click", closeCreateShapeModal);
        }
        if (createShapeModalSave) {
          createShapeModalSave.addEventListener("click", () => {
            const draft = readCreateShapeFormShape();
            const validation = validateCreateShapeDraft(draft, { strict: true });
            if (!validation.ok) {
              setStatus(validation.message, "error");
              return;
            }
            applyShapeKind(draft, draft.kind);
            triorbShapes.push(JSON.parse(JSON.stringify(draft)));
            const selectedFieldsets = getCreateShapeSelectedFieldsets();
            const attached = attachShapeToFieldsets(draft.id, selectedFieldsets);
            renderTriOrbShapes();
            renderTriOrbShapeCheckboxes();
            renderFieldsets();
            renderFigure();
            setStatus(
              `${draft.name} を追加しました（${attached} フィールドに紐付け）。`,
              "ok"
            );
            closeCreateShapeModal();
          });
        }
        if (createShapeModal) {
          createShapeModal.addEventListener("input", handleCreateShapeFormInput);
          createShapeModal.addEventListener("change", handleCreateShapeFormInput);
          createShapeModal.addEventListener("click", (event) => {
            if (event.target?.dataset?.action === "close-create-shape") {
              closeCreateShapeModal();
            }
          });
        }
        if (createShapeFieldsetList) {
          createShapeFieldsetList.addEventListener("click", (event) => {
            const button = event.target.closest(".toggle-pill-btn");
            if (!button) {
              return;
            }
            event.preventDefault();
            const isActive = button.classList.toggle("active");
            button.setAttribute("aria-pressed", isActive ? "true" : "false");
          });
        }
        function startCreateShapeDrag(event) {
          if (!createShapeModalWindow) return;
          isCreateShapeDragging = true;
          createShapeDragStartX = event.clientX;
          createShapeDragStartY = event.clientY;
          createShapeModalWindow.style.transition = "none";
        }
        function updateCreateShapeDrag(event) {
          if (!isCreateShapeDragging) return;
          const dx = event.clientX - createShapeDragStartX;
          const dy = event.clientY - createShapeDragStartY;
          if (createShapeModalWindow) {
            createShapeModalWindow.style.transform = `translate(${createShapeModalOffsetX + dx}px, ${createShapeModalOffsetY + dy}px)`;
          }
          createShapeLastDx = dx;
          createShapeLastDy = dy;
        }
        function endCreateShapeDrag() {
          if (!isCreateShapeDragging) return;
          createShapeModalOffsetX += createShapeLastDx;
          createShapeModalOffsetY += createShapeLastDy;
          isCreateShapeDragging = false;
          if (createShapeModalWindow) {
            createShapeModalWindow.style.transition = "";
            ensureCreateShapePosition();
          }
        }
        function startCreateShapeResize(event) {
          if (!createShapeModalWindow) return;
          isCreateShapeResizing = true;
          createShapeResizeStartX = event.clientX;
          createShapeResizeStartY = event.clientY;
          createShapeInitialWidth = createShapeModalWindow.offsetWidth;
          createShapeInitialHeight = createShapeModalWindow.offsetHeight;
          createShapeModalWindow.style.transition = "none";
        }
        function updateCreateShapeResize(event) {
          if (!isCreateShapeResizing || !createShapeModalWindow) return;
          const dx = event.clientX - createShapeResizeStartX;
          const dy = event.clientY - createShapeResizeStartY;
          const width = Math.max(360, createShapeInitialWidth + dx);
          const height = Math.max(360, createShapeInitialHeight + dy);
          createShapeModalWindow.style.width = `${width}px`;
          createShapeModalWindow.style.height = `${height}px`;
        }
        function endCreateShapeResize() {
          isCreateShapeResizing = false;
          if (createShapeModalWindow) {
            createShapeModalWindow.style.transition = "";
          }
        }
        if (createShapeModalHeader) {
          createShapeModalHeader.addEventListener("pointerdown", startCreateShapeDrag);
        }
        const resizeHandle = document.createElement("div");
        resizeHandle.className = "modal-resize-handle";
        if (createShapeModalWindow) {
          createShapeModalWindow.appendChild(resizeHandle);
        }
        resizeHandle.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          startCreateShapeResize(event);
        });
        document.addEventListener("pointermove", (event) => {
          updateCreateShapeDrag(event);
          updateCreateShapeResize(event);
        });
        document.addEventListener("pointerup", () => {
          endCreateShapeDrag();
          endCreateShapeResize();
        });

        if (toggleLegendBtn) {
          toggleLegendBtn.addEventListener("click", () => {
            legendVisible = !legendVisible;
            toggleLegendBtn.textContent = legendVisible ? "Hide Legend" : "Show Legend";
            setStatus(legendVisible ? "Legend visible." : "Legend hidden.", legendVisible ? "ok" : "warning");
            renderFigure();
          });
        }

        fileInput.addEventListener("change", (event) => {
          const file = event.target.files?.[0];
          if (!file) {
            return;
          }

          const reader = new FileReader();
          reader.onload = () => {
            try {
              const { traces, warning, triOrbPresent } = parseXmlToFigure(reader.result);
              const layout = cloneFigure(defaultFigure).layout;
              currentFigure = { data: traces, layout };
              renderFigure();
              if (warning) {
                setStatus(`${file.name} loaded with warnings: ${warning}`, "warning");
              } else {
                setStatus(
                  `${file.name} loaded${triOrbPresent ? " (TriOrb)" : ""}.`
                );
              }
            } catch (error) {
              console.error(error);
              setStatus(error.message || "Failed to load file.", "error");
            } finally {
              fileInput.value = "";
            }
          };
          reader.readAsText(file, "utf-8");
        });

        window.addEventListener("resize", () => {
          syncPlotSize();
          Plotly.Plots.resize(plotNode);
        });

        plotNode.on("plotly_hover", (event) => {
          if (event?.points?.length) {
            lastHoverPoint = event.points[0];
          }
        });

        plotNode.on("plotly_click", (event) => {
          const point = event?.points?.[0] || lastHoverPoint;
          console.debug("plotly_click", { point, lastHoverPoint });
          const meta = point?.meta || point?.data?.meta;
          if (meta?.kind) {
            console.debug("trigger modal", meta);
            renderShapeModal(meta);
          }
        });
        if (shapeModal) {
          shapeModal.addEventListener("click", (event) => {
            if (event.target?.dataset?.action === "close-modal") {
              cancelShapeModal();
            }
          });
        }
        if (shapeModalBody) {
          shapeModalBody.addEventListener("input", handleShapeModalInput);
        }
        if (shapeModalCancel) {
          shapeModalCancel.addEventListener("click", cancelShapeModal);
        }
        if (shapeModalClose) {
          shapeModalClose.addEventListener("click", cancelShapeModal);
        }
        if (shapeModalSave) {
          shapeModalSave.addEventListener("click", saveShapeModal);
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            if (createShapeModal?.classList.contains("active")) {
              closeCreateShapeModal();
            } else {
              cancelShapeModal();
            }
          }
        });
        if (shapeModalHeader) {
          shapeModalHeader.addEventListener("pointerdown", startModalDrag);
        }
        document.addEventListener("pointermove", updateModalDrag);
        document.addEventListener("pointerup", endModalDrag);

        setupLayoutObservers();
        renderFigure();

        function setupLayoutObservers() {
          if (typeof ResizeObserver === "undefined") {
            return;
          }
          const observer = new ResizeObserver(() => {
            syncPlotSize();
            Plotly.Plots.resize(plotNode);
          });
          const contentArea = document.querySelector(".content-area");
          const sideMenu = document.querySelector(".side-menu");
          if (contentArea) observer.observe(contentArea);
          if (sideMenu) observer.observe(sideMenu);
        }
      });
    </script>
  </body>
</html>